<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ES6学习（18）- Module模块化]]></title>
    <url>%2F2019%2F08%2F21%2FES6-18-module%2F</url>
    <content type="text"><![CDATA[基本概念ES6 的模块化语法 12345678910111213141516//导出用export 变量export let A = 123;//导出函数export function test()&#123; console.log('test');&#125;//导出类export class Hello&#123; test()&#123; console.log('class'); &#125;&#125; 在需要导入文件中写法 1234//花括号中需要哪项就 导入哪项 import &#123;A,test,Hello&#125; form `./$&#123;js路径&#125;`console.log(A,test,Hello); 第二种写法12345&#123; import * as lesson form `./$&#123;js路径&#125;` console.log(lesson.A,lesson.test);&#125; 另一种写法需要导出的文件： 12345678910111213141516let A = 123;let test = function()&#123; console.log('class');&#125;class Hello&#123; test()&#123; console.log('class'); &#125;&#125;//书写需要导出的类 变量 类export default&#123; A, test, Hello&#125; 导入文件： 123import lesson form '$&#123;js路径&#125;'console.log(lesson.A,lesson.test);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（17）- Decorators]]></title>
    <url>%2F2019%2F08%2F21%2FES6-17-decorators%2F</url>
    <content type="text"><![CDATA[Decorator修饰器 修饰函数类的行为，也可以理解为 类的扩展功能 基本用法需要安装插件 1npm install babel-plugin-transform-decorators-legacy --save-dev 修改babel文件 添加插件plugins:[babel-plugin-transform-decorators-legacy] 12345678910111213141516171819202122232425262728293031323334353637&#123; //限制某个属性是只读的 let readonly = function(target,name,descriptor)&#123; descriptor.writable = false; return decriptor &#125;; //修饰器 class Test&#123; @readonly //修改readonly 的行为 让其只读 time()&#123; return '2017-08-06'; &#125; &#125; let test = new Test(); rtest.time = function()&#123; console.log('rest time'); &#125; console.log(test.time());//Cannot assign to read only property 'time' of object '#&lt;Test&gt;'&#125;&#123; let typename = function(target,name,descriptor)&#123; target.myname = 'hello'; &#125; @typename //修饰器在类的外部 class Test&#123; &#125; console.log('类修饰符',Test.myname); //hello&#125; 第三方库 修饰器的js库：core-decortors;内置以上的方法 可以通过下载npm install core-decorators 12345678910111213141516171819202122232425&#123; let log=(type)=&gt;&#123; return function(target,name,descriptor)&#123; let src_method = descriptor.value; descriptor.value = (...arg)=&gt;&#123; src_method.apply(target,arg); console.log(`log$&#123;type&#125;`); &#125; &#125; &#125; class AD&#123; @log('show') show()&#123; console.info('ad is show'); &#125; @log('click') click()&#123; console.info('ad is click'); &#125; &#125; let ad = new AD(); ad.show();//ad is show ad.click();//ad is show&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（16）- Generator]]></title>
    <url>%2F2019%2F08%2F21%2FES6-16-generator%2F</url>
    <content type="text"><![CDATA[Generator 基本概念异步编程的总解决方案Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。 Generator 函数有多种理解角度。从语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。 执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。 形式上，Generator 函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield表达式，定义不同的内部状态（yield在英语里的意思就是“产出”）。 123456789101112131415&#123; //generator基本定义 let tell = function*()&#123; yield 'a'; yield 'b'; return 'c' &#125;; let k = tell(); console.log(k.next());//Object&#123;value:'a',done:false&#125; console.log(k.next());/Object&#123;value:'b',done:false&#125; console.log(k.next());//Object&#123;value:'c',done:true&#125; console.log(k.next());//Object&#123;value:ubdefined,done:true&#125; &#125; 12345678910111213&#123; let obj=&#123;&#125;; //创建generator函数 obj[Symbol.ierator]=function*()&#123; yield 1; yield 2; yield 3; &#125; for(let value of obj)&#123; console.log('value',value); &#125;&#125; generator的最大作用 状态机 12345678910111213141516&#123; let state = function*()&#123; while(1)&#123; yield 'A'; yield 'B'; yield 'c'; &#125; &#125; let status = state(); console.log(status.next());//A console.log(status.next());//B console.log(status.next());//C console.log(status.next());//A console.log(status.next());//B&#125; next 函数用法yield*的语法抽奖次数 逻辑 1234567891011121314151617181920212223242526&#123; let draw = function(count)&#123; //具体抽奖逻辑 //输出剩余次数 console.info(`剩余$&#123;count&#125;次`); &#125; let residuce = function*(count)&#123; while(cuont&gt;0)&#123; count--; //抽奖具体逻辑 yield draw(count); &#125; &#125; let star = residue(5); let btn = document.createElement('button'); btn.id = 'start'; btn.textContent = '抽奖'; document.body.appendChild(btn); document.getElementById('start').addEventListener('click',function()&#123; star.next(); &#125;,false);&#125; 长轮询123456789101112131415161718192021222324252627&#123; //长轮询 let ajax = function* ()&#123; yield new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(&#123;code:0&#125;) &#125;,200) &#125;) &#125; let pull = function()&#123; let genertaor = jax(); let step = genertaor.next(); step.value.then(function(d)&#123; if(d.code!=0)&#123; setTimeout(function()&#123; console.info('wait'); pull(); &#125;,1000); &#125;else &#123; console.info(d); &#125; &#125;) &#125; pull();//Object &#123;code:0&#125;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（15）- Iterator]]></title>
    <url>%2F2019%2F08%2F21%2FES6-15-iterator%2F</url>
    <content type="text"><![CDATA[Iterator接口在整个es6中，操作数据结构，数据结合的读取方式 Iterator 的基本用法调用方式 arrSymbol.iterator 12345678&#123; let arr=['hello world!']; let map= arr[Symbol.iterator](); console.log(map.next());//Object &#123;value:'hello',done:false&#125; console.log(map.next());//Object &#123;value:'world',done:false&#125; console.log(map.next());//Object &#123;value:undefined,done:false&#125;&#125; 自定义 Iterator 接口 123456789101112131415161718192021222324252627282930313233&#123; let obj=&#123; start:[1,3,2]; end:[7,9,8]; //es6新增方式 [Symbol.iterator]()&#123; let self = this; let index=0; let arr=self.start.concat(self.end); let len =arr.length; return &#123; //返回对象必须要包含next() next()&#123; //遍历的过程 if(index&lt;length)&#123; return &#123; value:arr[index++],//当前遍历 done:false//表示是否结束 &#125; &#125;else&#123; return &#123; value:arr[index++]; done:true &#125; &#125; &#125; &#125; &#125; &#125; for(let key of obj)&#123; console.log(key); &#125;&#125; for…of…123456&#123; let arr=['hello world!']; for(let value of arr)&#123; console.log('value',value);//value hello,value world! &#125;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（14）- Promise]]></title>
    <url>%2F2019%2F08%2F21%2FES6-14-promise%2F</url>
    <content type="text"><![CDATA[Promise 概念Promise 是异步编程的解决方案 什么是异步有一个函数A ，A执行完后执行B，异步方式有： 回调方式， 事件触发 Promise 不同于以上两种方式 Promise 的作用用来解决异步操作的解决方法 Promise的基本用法之前的写法123456789101112131415&#123; //基本定义 用 计时器模拟ajax 的回调 let ajax = function(callback)&#123; console.log('执行'); setTimeout(function()&#123; callback &amp;&amp; callback.call(); &#125;,1000); &#125;; ajax(function()&#123; console.log('timeout1'); &#125;); //先输出'执行' 1s后输出timeout1&#125; 这样写影响后期维护，回调的顺序很乱 使用Promise123456789101112131415&#123; let ajax=function()&#123; console.log('执行2'); //返回new Promise实例 该实例有个then()方法 resolve 表示执行下一步 reject中断当前操作 return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(); &#125;,1000); &#125;); &#125; //then()方法 表示执行下一步 ajax().then(function()&#123; console.log('promise','timeout2'); &#125;)&#125; 串行过程 ，then()链式操作12345678910111213141516171819202122&#123; let ajax=function()&#123; console.log('执行3'); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(); &#125;,1000); &#125;); &#125; ajax() .then(function()&#123; //继续返回Promise实例 return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; resolve(); &#125;,2000); &#125;) &#125;) .then(function()&#123; console.log('timeout3'); &#125;);&#125; catch 捕获异常错误 12345678910111213141516171819202122232425&#123; let ajax=function(num)&#123; console.log('执行4'); return new Promise(function(resolve,reject)&#123; setTimeout(function()&#123; //如果参数大于5 继续向下执行 if(num&gt;5)&#123; resolve(); &#125;else &#123;//否则 抛出错误 throw new Error('出错了'); &#125; &#125;,1000); &#125;); &#125; ajax(6).then(function()&#123; console.log('log',6);// log 6 &#125;).catch(function(err)&#123; console.log('catch',err); &#125;); ajax(3).then(function()&#123; console.log('log',3); &#125;).catch(function(err)&#123; console.log('catch',err);//catch 出错了 &#125;);&#125; Promise 高级用法fade流 今日头条、uc 新闻案例 加载新闻图片 Promise.all 所有图片加载完再添加到页面 123456789101112131415161718192021222324252627&#123; //所有图片加载完再添加到页面 function loadImg(src)&#123; return new Promise((resolve,reject)=&gt;&#123; let img = document.creatElement('img'); img.src=src; //本身就是一个Promise实例 img.onload = function()&#123; resolve(img); &#125; img.onerror=function(err)&#123; reject(err); &#125; &#125;) &#125; function showImgs(imgs)&#123; imgs.forEach(function(img)&#123; document.body.appendChild(img); &#125;) &#125; //加载图片 Promise.all返回的是一个实例 表示把多个 promise 实例当做一个promise实例来 Promise.all([ loadImg('https://img.com/1.png'), loadImg('https://img.com/2.png'), loadImg('https://img.com/3.png') ]).then(showImgs)&#125; 先到先得 Promise.race 表示有一个状态率先改变 那么这个race 状态就改变 123456789101112131415161718192021222324252627&#123; //有一个图加载完 就添加到页面中 function loadImg(src)&#123; return new Promise((resolve,reject)=&gt;&#123; let img = document.creatElement('img'); img.src=src; img.onload = function()&#123; resolve(img); &#125; img.onerror=function(err)&#123; reject(err); &#125; &#125;) &#125; function showImgs(img)&#123; let p = document.creatElement('p'); p.appendChild(img); document.body.appendChild(p); &#125; Promise.race([ loadImg('https://img.com/1.png'), loadImg('https://img.com/2.png'), loadImg('https://img.com/3.png') ]).then(showImgs)&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（13）- 类与对象]]></title>
    <url>%2F2019%2F08%2F21%2FES6-13-class%2F</url>
    <content type="text"><![CDATA[类类的概念 - - - 基本语法 类的继承 静态方法 静态属性 getter setter class 基本定义和生成实例 1234567891011&#123; //基本定义和生成实例 通过class + 关键字 类来定义类 class Parent&#123; constructor(name='mukewang')&#123; this.name = name; &#125; &#125; let v_parent = new Parent('v'); console.log('构造函数的实例',v_parent);// v_parent &#123;name 'v'&#125;&#125; 类的继承1234567891011121314&#123; //继承 class Parent&#123; constructor(name='mukewang')&#123; this.name = name; &#125; &#125; //使用 extends继承 class Child extends Parent&#123; &#125; console.log('继承', new Child());// 继承 Child &#123;name 'mukewang'&#125; &#125; 继承传递参数 修改参数12345678910111213141516171819&#123; //继承传递参数 class Parent&#123; constructor(name='mukewang')&#123; this.name = name; &#125; &#125; //使用 extends继承 class Child extends Parent&#123; constructor(name='child')&#123; super(name); //定义自己属性要用this 一定要用 super 的后边 this.type='child'; &#125; &#125; console.log('继承', new Child('hello'));// 继承 Child &#123;name： 'hello',type:'child'&#125; &#125; getter,setter12345678910111213141516171819202122&#123; //getter,setter class Parent&#123; constructor(name='mukewang')&#123; this.name = name; &#125; &#125; //属性 不是方法 get longName()&#123; return 'mk'+this.name &#125; set longName(value)&#123; this.name = value; &#125; let v= new Parent(); console.log('getter',v.longName);//getter mkmukewang v.longName='hello'; console.log('setter',v.longName); //setter mkhello&#125; 类的 静态方法使用 static 关键词 后边加 方法名称 所以 就变成静态方法 静态方法意思就是 通过 类去调用 而不是通过 类的实例去调用1234567891011121314&#123; //静态方法 class Parent&#123; constructor(name='mukewang')&#123; this.name = name; &#125; &#125; //静态方法 使用 static 关键词 后边加 方法名称 所以 就变成静态方法 静态方法意思就是 通过 类去调用 而不是通过 类的实例去调用 static tell()&#123; console.log('tell'); &#125; //调用 用类去调用 Parent.tell();//tell&#125; 类的 静态属性12345678910111213141516&#123; //静态属性 class Parent&#123; constructor(name='mukewang')&#123; this.name = name; &#125; &#125; //静态方法 static tell()&#123; console.log('tell'); &#125; //静态属性 Parent.type='test'; console.log('静态属性',Parent.type);// 静态属性 test &#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（12）- Proxy和Reflect]]></title>
    <url>%2F2019%2F08%2F21%2FES6-12-proxy-reflect%2F</url>
    <content type="text"><![CDATA[Proxy和Reflect的概念Proxy对象代理 生成对象： new Proxy(); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&#123; let obj = &#123; time:'2017-03-11', name:'net', _r:123 &#125;; //第一个参数是需要代理的对象 ，第二个是代理的方法 let monitor = new Proxy(obj,&#123; //拦截对象属性的读取，跟代理是一个意思 target get(target,key)&#123; return target[key].replace('2017','2018'); &#125;, //拦截对象设置属性 set(target,key,value)&#123; if(key==='name')&#123; return target[key]=value; &#125;else &#123; return target[key]; &#125; &#125;, //拦截 key in object 操作 has(target,key)&#123; if(key==='name')&#123; return target[key]; &#125;else&#123; return false; &#125; &#125;, //拦截delete deleteProperty(target,key)&#123; if(key.indexOf("_"&gt;-1))&#123; delete target[key]; return true; &#125;else &#123; return target[key]; &#125; &#125;, //拦截object.keys,Object.getOwnPropertySymbols,Object.getOwnPropertyNames ownKeys(target)&#123; return Object.keys(target).filter(filter(item=&gt;item!='time'));//过滤掉time属性 ，不让返回 &#125; &#125;); console.log('get',monitor.time);//get 2018-03-11 monitor.name='mukewang'; console.log('set',monitor.time,monitor);//set 2018-03-11 Proxy&#123;time:'2017-03-11',name:'mukewang',_r:123&#125; console.log('has','name'in monitor,'time' in monitor);//has true false; delete.monitor.time; console.log('delete',monitor); //time没有被删除 还是全部 输出 Proxy&#123;time:'2017-03-11',name:'mukewang',_r:123&#125; delete.monitor._r; console.log('delete',monitor);//Proxy&#123;time:'2017-03-11',name:'mukewang',&#125; console.log('ownKeys',Object.keys(monitor));//Proxy &#123;time,_r&#125;&#125; Reflect对象反射的是Object 生成对象： 直接 Reflect 1234567891011121314&#123; let obj = &#123; time:'2017-03-11', name:'net', _r:123 &#125;; console.log('Reflect get',Reflect.get(obj,'time'));//Reflect get time:"2017-03-11", Reflect.set(obj,'name','mukewang'); console.log('Reflect set', obj);//'Reflect set' Object &#123;time:"2017-03-11",name:"mukewang",_r:123&#125; console.log('Reflect has',Reflect.has(obj,'name'));//true &#125; Proxy和Reflect的适用场景通用方式 数的校验，数据类型 格式校验 表单验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#123; function validator(target,validator)&#123; return new Proxy(target,&#123; _validator:validator, set(target,key,value,proxy)&#123; if(target.hasOwnProperty(key))&#123; let va=this._validator[key]; if(!!va(value))&#123; return Reflect.set(target,key,value,proxy) &#125;else&#123; throw Error(`不能设置$&#123;key&#125;到$&#123;value&#125;`) &#125; &#125;else&#123; throw Error(`$&#123;key&#125; 不存在`) &#125; &#125; &#125;) &#125; const personValidators=&#123; name(val)&#123; return typeof val==='tring' &#125;, age(val)&#123; return typeof val==='number' &amp;&amp; val&gt;18 &#125; &#125; class Person&#123; constructor(name,age)&#123; this.name = name; this.age = age; return validator(this,personValidators) &#125; &#125; const =person = new Person('lilei',30); console.info(person);//Proxy &#123;name,'lilei',age,30&#125; person.name = 48; console.info(person);//throw Error '不能设置name 到 48' person.name = 'Han meimei'; console.info(person);//Proxy &#123;name,'Han meimei',age,30&#125;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（11）- map-set与数组和对象的比较]]></title>
    <url>%2F2019%2F08%2F21%2FES6-11-Set-Map%2F</url>
    <content type="text"><![CDATA[Map 与Array的对比 1234567891011121314151617181920212223242526272829303132&#123; //数据结构的横向对比 增、删、改、查 let map = new Map(); let array=[]; //增 map.set('t',1); array.push(&#123;t:1&#125;); console.info('map-array',map,array); //查 let map_exist = map.has('t'); let array_exist =array.find(item=&gt;item.t); console.info('map-array',map_exist,array_exist);//true Object&#123;t:1&#125; 第一个返回的事布尔值 第二个直接返回对象 //改 map.set('t',2); //通过数组的forEach遍历，看数组中是否存在该值 ，如果存在 ，改变其值，如果不存在 ，返回空 array.forEach(item=&gt;item.t?item.t=2:''); console.info('map-array-modify',map,array); //Map(1)&#123;'t',2&#125; //删 map.delete('t'); let idnex = array.findIndex(item=&gt;item.t); array.splice(index,1); console.info('map-array-empty',map,array);// Map(0) &#123;&#125; &#125; Set 与Array的对比12345678910111213141516171819202122232425262728293031 &#123; //set和array 的对比 let set = new Set(); let array =[]; //增 set.add(&#123;t:1&#125;); array.push(&#123;t:1&#125;); console.info('set-array',set,array); //Set(1) &#123;Object &#123;t:1&#125;&#125; //查 let set_exist = set.has(&#123;t:1&#125;); let array_exist =array.find(item=&gt;item.t); console.info('set-array',set_exist,array_exist);//false //改 set.forEach(item =&gt;item.t?item.t=2:''); array.forEach(item =&gt;item.t?item.t=2:''); console.info('set-array-modefy',set_exist,array_exist);// Set(1) Object&#123;t:2&#125; //删 set.forEach(item=&gt;item.t?set.delete(item):''); let index = array,findIndex(item=&gt;item.t); arr.splice(index,1); console.info('set-array-empty',set,array);// Set(0) &#123;&#125;&#125; Map , Set , Object 的对比123456789101112131415161718192021222324252627282930313233343536&#123; //Map,Set ,Objec 对比 let item= &#123;t:1&#125;; let map = new Map(); let set = new Set(); let obj = &#123;&#125;; //增 map.set('t':1); set.add(item); obj['t']=1; console.info('map-set-obj',map,set,obj);//Map(1)&#123;"t"=&gt;1&#125; set(1) &#123;Object&#123;t:1&#125;&#125; Object&#123;t:1&#125; //查 console.info(&#123; map_exist:map.has('t'); set_exist:set.has(item); obj_exist:'t' in obj &#125;);//map_exist:true;set_exist: true;obj_exist:true //改 map.set('t',2); item.t=2; obj['t']=2; console.info('map-set-obj-modify',map,set,obj);//Map(1)&#123;'t'=&gt;2&#125; Set(1) &#123;Object &#123;t:2&#125;&#125; Object &#123;t:2&#125; //删 map.delete('t'); set.delete(item); delete obj['t']; console.log('set-array-empty',map,set,obj);//Map(0) Set(0) Object &#123;&#125; &#125; 通过上边的对比 ，可以看出：对于复杂的数组结构，优先使用Map，如果要求 数组的唯一性，则使用Set()，在数据的存储中尽量使用 Map,而放弃使用 Object 和数组]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（10）- set-map数据结构]]></title>
    <url>%2F2019%2F08%2F21%2FES6-10-Set-Map%2F</url>
    <content type="text"><![CDATA[Set的用法当做数组去用 Set 集合中的元素是不能重复的 12345678910&#123; //声明普通的变量 let list = new Set(); //添加两个元素 list.add(5); list.add(7); //长度 .size console.log('size',list.size);//size 2&#125; Set 初始化的时候就把元素初始化进去 123456&#123; let arr = [1,2,3,4,5]; let list = new Set(arr); console.log('size',list.size);//size 5 &#125; Set 数据元素必须是唯一的,不能重复 1234567891011121314151617181920&#123; let list = new Set(); list.add(1); list.add(2); list.add(1); //添加重复的元素不会添加进去的 ，也不会报错 console.log('list',list); //list 1 ,list 2 let arr=[1,2,3,1,'2']; let list2=new Set(arr); //不会做数据类型的转化 console.log('unique',list2);//unique Set&#123;1,2,3,'2'&#125; 成功的过滤掉重复的元素 但是后边的字符串 ‘2’ 也输出了 //通过new Set（）去重，然后转换为数组 let arrs =[1,2,3,4,1,3,"tre"]; let sets = new Set(arrs); Array.from(sets) //[1,2,3,4,"tre"]&#125; Set 的使用方法 list.add()，数组中添加元素 list.deledte()， 数组中移除元素 list.clear()，数组中清空元素 list.has() ，数组中判断有无元素 123456789&#123; let arr=['add','delete','clear','has']; let list=new Set(arr); console.log('has',list.has('add')); console.log('delete',list.delete('add'),list); list.clear(); console.log('list',list);&#125; Set 实例的遍历 （读取） 12345678910111213141516171819202122&#123; let arr=['add','delete','clear','has']; let list=new Set(arr); //用 for... of... 遍历 for(let key of list.keys())&#123; console.log('keys',key);// keys add, keys delete,keys clear,keys has &#125; for(let value of list.values())&#123; console.log('value',value);// keys add, keys delete,keys clear,keys has 打印出来跟上边的一样 都是 元素的名称 &#125; for(let value of list)&#123; console.log('value',value);// keys add, keys delete,keys clear,keys has 直接遍历list也是也可的 值跟上边的一样 &#125; for(let [key,value] of list.entries())&#123; console.log('entries',key,value);//打印出了 entries and and ,entries delete delete, entries clear clear, entries has has &#125; //foreach 遍历 返回 item // and delete clear has list.forEach(function(item)&#123;console.log(item);&#125;)&#125; WeakSet的用法WeakSet 与 Set的比较 WeakSet 跟Set的支持数据类型不一样， WeakSet只是必须是对象 不能是 数值 字符串 WeakSet 是弱引用，不会检测这个对象在其他地方用过 ，不会检测器其是否在垃圾回收掉 没有clear 方法 12345678910111213&#123; //生成weakSet变量 let weakList=new WeakSet(); let arg=&#123;&#125;; weakList.add(arg); // weakList.add(2); // 不支持其他的类型 只能是对象 console.log('weakList',weakList); //weakList wekSet &#123;Object&#123;&#125;&#125;&#125; Map的用法key 可以是任意的类型 数字 字符串12345678&#123; let map = new Map(); let arr=[&apos;123&apos;]; // Map() 添加元素用 .set()不是 .add() map.set(arr,456); console.log(&apos;map&apos;,map,map.get(arr));// map Map&#123;[&quot;123&quot;]=&gt;456&#125; 456 &#125; 12345678&#123; let map = new Map([['a',123],['b',456]]); console.log('map args',map); // a=&gt;123 b=&gt;456 console.log('size',map.size);//2 console.log('delete',map.delete('a'),map);//b=&gt;456 console.log('clear',map.clear(),map); //map&#123;&#125;&#125; WeakMap的用法weakMap 与Map 跟 WeakSet 与 Set的 的区别一样12345678&#123; let weakmap=new WeakMap(); let o=&#123;&#125;; weakmap.set(o,123); console.log(weakmap.get(o));//123&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（9）- Symbol]]></title>
    <url>%2F2019%2F08%2F21%2FES6-09-symbol%2F</url>
    <content type="text"><![CDATA[Symbol 概念Symbol()声明的变量永远都是独一无二的 123456789&#123; // 声明 let a1=Symbol();//生成一个独一无二的值 let a2=Symbol(); console.log(a1===a2);//false let a3=Symbol.for('a3'); let a4=Symbol.for('a3'); console.log(a3===a4);//true&#125; Symbol 作用12345678910111213141516171819202122232425&#123; let a1=Symbol.for('abc'); let obj=&#123; [a1]:'123', 'abc':345, 'c':456 &#125;; console.log('obj',obj);//Object abc:345 c:456 Symbol(abc):"123" 这跟之前的abc不冲突 for(let [key,value] of Object.entries(obj))&#123; console.log('let of',key,value); &#125; // let of abc 345,let of c 456 拿不到a1（Symbol.for('abc')）的值 //getOwnPropertySymbols 只能拿到 Symbol.for('abc')的值 Object.getOwnPropertySymbols(obj).forEach(function(item)&#123; console.log(obj[item]);//123 &#125;) //Reflect.ownKeys(obj) 能返回了 所有的key 和value 值（包括Symbol.for('abc') 的值 ） Reflect.ownKeys(obj).forEach(function(item)&#123; console.log('ownkeys',item,obj[item]); &#125;)&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（8）- 对象扩展]]></title>
    <url>%2F2019%2F08%2F21%2FES6-08-object%2F</url>
    <content type="text"><![CDATA[简介表示法注意下列ES5，ES6代码的不同写法1234567891011121314151617181920212223242526272829&#123; // 简洁表示法 let o=1; let k=2; //es5的写法 let es5=&#123; o:o, k:k &#125;; //es6的写法 let es6=&#123; o, k &#125;; console.log(es5,es6); //es5中的方法 let es5_method=&#123; hello:function()&#123; console.log('hello'); &#125; &#125;; //es6中的方法 let es6_method=&#123; hello()&#123; console.log('hello'); &#125; &#125;; console.log(es5_method.hello(),es6_method.hello());&#125; 属性表示法123456789101112131415&#123; // 属性表达式 let a='b'; let es5_obj=&#123; a:'c', b:'c' &#125;; //key 值，表达式 let es6_obj=&#123; [a]:'c' &#125; console.log(es5_obj,es6_obj);&#125; es6_obj输出的值为 b:&#39;c&#39; 扩展运算符Object.is 判断是否相等Object.assign 浅拷贝Object.entries 对象的遍历12345678910111213&#123; // 新增API console.log('字符串',Object.is('abc','abc'),'abc'==='abc'); true true console.log('数组',Object.is([],[]),[]===[]);//false false //浅拷贝 console.log('拷贝',Object.assign(&#123;a:'a'&#125;,&#123;b:'b'&#125;)); let test=&#123;k:123,o:456&#125;; for(let [key,value] of Object.entries(test))&#123; console.log([key,value]); &#125;&#125; Object新增方法扩展运算符 12345678&#123; // 扩展运算符 // let &#123;a,b,...c&#125;=&#123;a:'test',b:'kill',c:'ddd',d:'ccc'&#125;; // c=&#123; // c:'ddd', // d:'ccc' // &#125;&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（7）- 函数扩展]]></title>
    <url>%2F2019%2F08%2F21%2FES6-07-function%2F</url>
    <content type="text"><![CDATA[参数默认值函数参数里边直接赋默认值，但是可以被重新赋值1234567&#123; function test(x, y = 'world')&#123; console.log('默认值',x,y); &#125; test('hello'); test('hello','kill');&#125; 强调：默认值的后边不能再有没有默认值的变量，比如在y = &#39;world&#39;后边添加个参数c，这样就会报错，如果写成c = &#39;www&#39;这样是可以的 作用域1234567&#123; let x='test'; function test2(x,y=x)&#123; console.log('作用域',x,y);//kill kill &#125; test2('kill');&#125; 如果test2()不赋值，那么输出为undefined undefined；但是如果把第一个参数x变为c，那么输出的值为 kill test，它会把上边x的值给y rest参数…;作用是把一系列的参数转换为一个数组 12345678&#123; function test3(...arg)&#123; for(let v of arg)&#123; console.log(&apos;rest&apos;,v);//rest 1,rest2,rest 3,rest 4,rest a, &#125; &#125; test3(1,2,3,4,&apos;a&apos;);&#125; 注意rest参数之后就不能有其他参数 扩展运算符rest的逆运算把数组拆成了离散的值 1234&#123; console.log(...[1,2,4]);//1,2,4 console.log(&apos;a&apos;,...[1,2,4]);//a,1,2,4&#125; 箭头函数 =&gt;先看下边箭头函数的代码：1234567&#123; let arrow = v =&gt; v*2; let arrow2 = () =&gt; 5; console.log(&apos;arrow&apos;,arrow(3));//arrow 6 console.log(arrow2());//5&#125; 上边第一个函数 的arrow为函数名，第二个v表示函数的参数；第三个=&gt;后边的表示执行的函数;第二个函数，如果箭头函数没有参数时 就写个() this绑定箭头函数中this的指向，指函数在定义是的指向的所在， ES5是函数在调用的时候的指向 注意作this绑定的时候要看特性，有事可用，有时勿用 尾调用尾调用存在于函数式编程的里边,主要能提升性能，主要针对函数嵌套123456789&#123; function tail(x)&#123; console.log(&apos;tail&apos;,x); &#125; function fx(x)&#123; return tail(x) &#125; fx(123)// tail 123&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（6）- 数组扩展]]></title>
    <url>%2F2019%2F08%2F21%2FES6-06-array%2F</url>
    <content type="text"><![CDATA[Array.of()Array.of()把一组数据变量转换成数据类型,如果里边不传任何参数，那么输出的就是一个空数组1234567&#123; let arr = Array.of(3,4,7,9,11); console.log('arr=',arr);//[3,4,7,9,11] let empty=Array.of(); console.log('empty',empty);//[]&#125; Array.from()Array.from() 把一些伪数组、集合转换为数组；为了演示这个功能 需要在在HTML里边添加几个标签123&lt;p&gt;张三&lt;/p&gt;&lt;p&gt;李四&lt;/p&gt;&lt;p&gt;王五&lt;/p&gt; 因为p是一个集合，需要把它转换为数组1234567891011&#123; let p=document.querySelectorAll('p'); let pArr=Array.from(p); pArr.forEach(function(item)&#123; console.log(item.textContent);//item.textContent；textContent 原生js获取dom节点文本内容的方法、属性 &#125;); //类似于Map()的映射的作用 console.log(Array.from([1,3,5],function(item)&#123;return item*2&#125;));//[2,6,10]&#125; 上边的Array.from()有两个参数，第一个为数组，第二个就相当于map 的作用，把里边每个元素都乘以2 Array.fill() 填充数组把数组内部的值全部替换成需要的值 123456&#123; console.log('fill-7',[1,'a',undefined].fill(7));//[7,7,7] //第一个参数表示替换的内容，第二个表示替换的起始位置，第三个参数为换的长度 console.log('fill,pos',['a','b','c'].fill(7,1,3));&#125; .keys()，.values()，.entries() .keys() 返回所有数组的下标（索引） .values() 返回数组的值 （现在存在兼容性问题，需要插件polylily） .entries() 既能取到索引，也能取到值 123456789101112&#123; for(let index of ['1','c','ks'].keys())&#123; console.log('keys',index);//0,1,2 &#125; for(let value of ['1','c','ks'].values())&#123; console.log('values',value);//1,c,ks &#125; for(let [index,value] of ['1','c','ks'].entries())&#123; console.log('values',index,value);// values 0 1 , values 1 c, values 2 ks &#125;&#125; .copyWithin()有三个参数；第一个参数为从那个位置开始替换，第二个值为读取数据的位置，第三个值为截至位置(使用频率不高) 123&#123; console.log([1,2,3,4,5].copyWithin(0,3,4));//[4,2,3,4,5]&#125; .find()，.findIndex()查找 .find() 内部可以写条件，只找出符合条件的第一个就停止查找了 .findIndex() 返回 找出符合条件的下标（索引） 1234&#123; console.log([1,2,3,4,5,6].find(function(item)&#123;return item&gt;3&#125;));//4 console.log([1,2,3,4,5,6].findIndex(function(item)&#123;return item&gt;3&#125;));//3&#125; .includes()判断数组中是否包含某个值 1234&#123; console.log('number',[1,2,NaN].includes(1));//number true 说明数组中包含1，也没有判断数组中有NaN console.log('number',[1,2,NaN].includes(NaN)); //number true 表示NaN也能找到 &#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（5）- 数值扩展]]></title>
    <url>%2F2019%2F08%2F21%2FES6-05-numerical-expansion%2F</url>
    <content type="text"><![CDATA[ES6 的 数值扩展 123456789101112131415161718192021222324252627282930313233343536373839404142434445&#123; console.log('B',0B111110111);//503； 二进制都是以'0B'开头，大小写都可以，后边跟二进制数字 console.log(0o767);//503 ；八进制是以'0o'开头后边跟八进制数字&#125;&#123; console.log('15',Number.isFinite(15));//15 true ;isFinite 判断有无群大；有尽 console.log('NaN',Number.isFinite(NaN));//NaN false console.log('1/0',Number.isFinite('true'/0));//1/0 false console.log('NaN',Number.isNaN(NaN));//NaN ture console.log('0',Number.isNaN(0));//0 false&#125;// Number.isInteger 判断是不是整数 &#123; console.log('25',Number.isInteger(25));//25 ture console.log('25.0',Number.isInteger(25.0));//25.0 ture console.log('25.1',Number.isInteger(25.1));//25.1 false console.log('25.1',Number.isInteger('25'));//25.1 false 不是数字&#125;&#123; console.log(Number.MAX_SAFE_INTEGER,Number.MIN_SAFE_INTEGER);//9007199254740991,-9007199254740991 判断最大值 最小值 console.log('10',Number.isSafeInteger(10));//ture 判断数是否安全范围的数 console.log('a',Number.isSafeInteger('a'));//false 不为数&#125;// Math.trunc(num) 判断带小数的整数部分 并返回&#123; console.log(4.1,Math.trunc(4.1));//4 console.log(4.9,Math.trunc(4.9));//4&#125;//Math.sign(num) 判断一个数到底为正数，负数，还是0&#123; console.log('-5',Math.sign(-5));//-5 -1 console.log('0',Math.sign(0));//0 0 console.log('5',Math.sign(5));//5 1 console.log('50',Math.sign('50'));//50 1 console.log('foo',Math.sign('foo'));//foo NaN (非数字)&#125;// Math.cbrt(num)立方根的计算 &#123; console.log('-1',Math.cbrt(-1));// -1 -1 console.log('8',Math.cbrt(8));//8 2&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（4）- 字符串扩展]]></title>
    <url>%2F2019%2F08%2F21%2FES6-04-string-extension%2F</url>
    <content type="text"><![CDATA[ES6的字符串扩展 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&#123; console.log('a',`\u0061`); console.log('s',`\u20BB7`); console.log('s',`\u&#123;20BB7&#125;`);&#125;&#123; let s='𠮷'; console.log('length',s.length); console.log('0',s.charAt(0)); console.log('1',s.charAt(1)); console.log('at0',s.charCodeAt(0)); console.log('at1',s.charCodeAt(1)); let s1='𠮷a'; console.log('length',s1.length); console.log('code0',s1.codePointAt(0));//取第一个字符的码值 console.log('code0',s1.codePointAt(0).toString(16));//取第一个字符的码值，转换为16进制 console.log('code1',s1.codePointAt(1)); console.log('code2',s1.codePointAt(2));&#125;&#123; console.log(String.fromCharCode("0x20bb7"));//es5 console.log(String.fromCodePoint("0x20bb7"));//es6 通过码值返回字符串&#125;&#123; let str='\u&#123;20bb7&#125;abc'; for(let i=0;i&lt;str.length;i++)&#123; console.log('es5',str[i]); &#125; for(let code of str)&#123;//遍历输出字符串 console.log('es6',code); &#125;&#125;&#123; let str="string"; console.log('includes',str.includes("c"));//查看字符串中包含‘c’字符 console.log('start',str.startsWith('str'));//判断字符串是否以'str'起始 console.log('end',str.endsWith('ng'));//判断字符串是否以'ng'结束&#125;&#123; let str="abc"; console.log(str.repeat(2));//指定重复的次数，相当于字符串的复制粘贴&#125;//*模板字符串(很重要)&#123; let name="list"; let info="hello world"; let m=`i am $&#123;name&#125;,$&#123;info&#125;`;//`` 不是单引号'' ,是 键盘上数字1左边的字符 console.log(m);&#125;// 字符串补白 （es7,需要babel-polyfill插件）&#123; console.log('1'.padStart(2,'0'));//01，补白的作用（es7），第一个参数‘2’表示两位，在前边补个0 console.log('1'.padEnd(2,'0'));//10，补白的作用（es7），在后边补个0&#125;// 标签模板 ，1防止xss攻击时用这个模板，2处理多语言转换 &#123; let user=&#123; name:'list', info:'hello world' &#125;; console.log(abc`i am $&#123;user.name&#125;,$&#123;user.info&#125;`); function abc(s,v1,v2)&#123; console.log(s,v1,v2); return s+v1+v2 &#125;&#125;//.raw 对所有的\进行了转译&#123; console.log(String.raw`Hi\n$&#123;1+2&#125;`); console.log(`Hi\n$&#123;1+2&#125;`);&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（3）- 正则扩展]]></title>
    <url>%2F2019%2F08%2F20%2FES6-03-regular-extension%2F</url>
    <content type="text"><![CDATA[在 ES5 中，RegExp构造函数的参数有两种情况。第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。12345&#123; // #构造函数# let regex = new RegExp('xyz', 'i'); //第一个参数是字符串，第二个是修饰符 let regex2 = new RegExp(/xyz/i); //第一个参数是正则表达式，不接受第二个参数，否则会报错&#125; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝123456789101112var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i;``` 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。```jsvar regex = new RegExp(/xyz/, 'i');// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another``` ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。```jsnew RegExp(/abc/ig, 'i').flags // "i" 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 ES61234&#123; let regex3 = new RegExp(/abc/ig, 'i'); console.log(regex3.flags); //原有正则对象的修饰符是ig，它会被第二个参数i覆盖&#125; es6 允许 第一个参数为正则表达式，也有第二个参数，为修饰符，原有正则对象的修饰符是ig，所以它会被第二个参数i覆盖 更多参考]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（2）- 解构赋值]]></title>
    <url>%2F2019%2F08%2F20%2FES6-02-destructuring%2F</url>
    <content type="text"><![CDATA[数组类的解构赋值12345&#123; let a,b,rest; [a,b]=[1,2];//等价于 let a = 1,b = 2; console.log(a,b);&#125; 上边的[a,b]=[1,2];等价于 let a = 1,b = 2 ; 12345&#123;let a,b,rest;[a,b,...rest] = [1,2,3,4,5,6];console.log(a,b,rest);//1,2,[3,4,5,6]&#125; 上边的[a,b,...rest] = [1,2,3,4,5,6];等价于 12345&#123; let a,b,c,rest; [a,b,c=3]=[1,2]; console.log(a,b,c);&#125; 如果上边的c=3改为c,那么直接就是输出的c为undefined，所以 c=3防止没有配对成功时的undefined 123456&#123; let a=1; let b=2; [a,b]=[b,a]; console.log(a,b);//2,1&#125; 通过解构赋值 可以实现变量交换，不用es5里边需要中间值存储 12345678&#123; fucntion f()&#123; return [1,2] &#125; let a,b; [a,b]=f(); console.log(a,b);//1,2&#125; 这是一个重要的场景如果我们没有解构赋值，我们想取到第一个或者第二个元素，那么我们得用一个变量来接收这个函数运行的结果，然后通过索引返回0,1两个位置返回的值，这样写比较麻烦，用ES6 写就很方便 1234567891011121314151617&#123; function f()&#123; return [1,2,3,4,5] &#125; let a,b,c; [a,,,b]=f(); console.log(a,b);//1,4&#125;&#123; function f()&#123; return [1,2,3,4,5] &#125; let a,b,c; [a,,...b]=f(); console.log(a,b);//1,[3,4,5]&#125; ,是把中间的值忽略获取 ； 对象类解构赋值新建一个块作用域12345&#123; let a,b; (&#123;a,b&#125;=&#123;a:1;b:2;&#125;) console.log(a,b);//1,2&#125; 12345&#123; let o=&#123;p:42,q:true&#125;; let &#123;p,q&#125;=o; console.log(p,q);//42,true&#125; 对象的解构赋值的左右必须为对象1234&#123; let &#123;a=10,b=5&#125;=&#123;a:3&#125;; console.log(a,b);//3,5&#125; 1234567891011&#123; let metaData=&#123; title:'abc', test:[&#123; title:'test', desc:'description' &#125;] &#125; let &#123;title:esTitle,test:[&#123;title:cnTitle&#125;]&#125;=metaData; console.log(esTitle,cnTitle);//abc,test&#125;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习（1）-let,const]]></title>
    <url>%2F2019%2F08%2F20%2FES6-01-let-const%2F</url>
    <content type="text"><![CDATA[let作用域的概念12345678910function test()&#123; //var a = 1; for(let i =1;i&lt;3;i++)&#123; console.log(i); &#125; console.log(i);&#125;test();//1,2，i is not defined 块作用域 ：如果一个方法（函数）用大括号包裹起来 ，那么这就是块级作用域；let只在块级作用域内有效； ES6 是强制启用严格模式 （’use strict’） 12let a = 1;let a = 2; 强调：以上会报错 * 使用let不能重复声明变量 constconst 用来定义成常量，常量的作用是其值不能修改 (不严谨);声明的时候必须赋值； 如：123456fucntion last()&#123; const PI = 3.1415926; PI = 8; console.log(PI);&#125;last();//报错 “PI” is read-only 上边PI 的值改变了 ，所以报错const 也是有块级作用域 123456789fucntion last()&#123; const PI = 3.1415926; const k = &#123; a:1 &#125; k.b = 3; console.log(PI,k);&#125;last(); 上边 用const声明 k 为一个对象 ；对象是引用类型，对象本身是可以变的，k只是指向的是其不变的指针]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue深度学习（6）- render 函数]]></title>
    <url>%2F2018%2F10%2F25%2Frender-function%2F</url>
    <content type="text"><![CDATA[render 研究方向 render机制 研究方法 条件渲染、列表渲染、update、模板、服务器渲染、渲染性能，如何编译，ast是什么 渲染函数 web页面渲染分四种方式 后端模板渲染： 指使用PHP等后端语言来生成页面，通常情况下，需要后端配合，混合项目开发。以前项目都这样搞，缺点大于优点 客户端渲染： 指使用 JS 来渲染页面大部分内容，后端资源都是通过ajax请求数据来渲染。代表是现在流行的 SPA 单页面应用； node中间层： 前后端分离，但优于前端直接请求接口从而产生的一系列问题。 比如可以用PHP写后端简单的接口，Node.js封装PHP接口，前端axios请求封装后的接口，将需要的数据返回到对应的view层页面，既解决了跨域问题（Node.js作为服务端，服务端没有跨域一说），同时又不需要配后端环境，只需要一个PHP接口 详细说明 服务端渲染（ssr）： 主要指的是ssr，在准确点说就是「同构渲染」指前后端共用 JS，首次渲染时使用 Node.js 来直出 HTML。一般来说同构渲染是介于前后端中的共有部分。 什么是render函数Render函数是Vue2.x版本新增的一个函数；使用虚拟dom来渲染节点提升性能，因为它是基于JavaScript计算。通过使用createElement(h)来创建dom节点。createElement是render的核心方法。其Vue编译的时候会把template里面的节点解析成虚拟dom； vue推荐在绝大多数情况下使用template来创建我们的HTML。然而在一些场景中，我们真的需要JavaScript的完全编程的能力，这就是render函数，它比template更接近编译器。 demo 在之前的Vue1.X版本中没有Virtual DOM,Vue2.0之后添加了此功能，而Virtual DOM 最后是通过render函数来生成模板页面vue 在new Vue()最后的渲染只认render 函数 所有的东西 html,template 都会编译成render函数 createElement 参数demo：123render (h) &#123; return h(&apos;div&apos;, &#123;&#125;, this.text)&#125; render函数里面的传参h就是Vue里面的createElement方法，return返回一个createElement方法，（官方文档：返回的其实不是一个实际的 DOM 元素。它更准确的名字可能是 createNodeDescription，因为它所包含的信息会告诉 Vue 页面上需要渲染什么样的节点，及其子节点。我们把这样的节点描述为“虚拟节点 (Virtual Node)”，也常简写它为“VNode”。“虚拟 DOM”是我们对由 Vue 组件树建立起来的整个 VNode 树的称呼。） 其中可以传三个参数： 第一个参数 {String | Object | Function} 表示可以传一个 HTML 标签字符串，组件选项对象，或者解析上述任何一种的一个 async 异步函数。必需参数； 第二个参数 {Object} 一个包含模板相关属性的数据对象，对象里面可以是我们组件上面的props，或者是事件之类的东西，你可以在 template 中使用这些特性。可选参数；data的对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 &#123; // 和`v-bind:class`一样的 API // 接收一个字符串、对象或字符串和对象组成的数组 'class': &#123; foo: true, bar: false &#125;, // 和`v-bind:style`一样的 API // 接收一个字符串、对象或对象组成的数组 style: &#123; color: 'red', fontSize: '14px' &#125;, // 普通的 HTML 特性 attrs: &#123; id: 'foo' &#125;, // 组件 props props: &#123; myProp: 'bar' &#125;, // DOM 属性 domProps: &#123; innerHTML: 'baz' &#125;, // 事件监听器基于 `on` // 所以不再支持如 `v-on:keyup.enter` 修饰器 // 需要手动匹配 keyCode。 on: &#123; click: this.clickHandler &#125;, // 仅用于组件，用于监听原生事件，而不是组件内部使用 // `vm.$emit` 触发的事件。 nativeOn: &#123; click: this.nativeClickHandler &#125;, // 自定义指令。注意，你无法对 `binding` 中的 `oldValue` // 赋值，因为 Vue 已经自动为你进行了同步。 directives: [ &#123; name: 'my-custom-directive', value: '2', expression: '1 + 1', arg: 'foo', modifiers: &#123; bar: true &#125; &#125; ], // 作用域插槽格式 // &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: props =&gt; createElement('span', props.text) &#125;, // 如果组件是其他组件的子组件，需为插槽指定名称 slot: 'name-of-slot', // 其他特殊顶层属性 key: 'myKey', ref: 'myRef', // 如果你在渲染函数中向多个元素都应用了相同的 ref 名， // 那么 `$refs.myRef` 会变成一个数组。 refInFor: true&#125; 第三个参数 {String | Array} 子虚拟节点 (VNodes)，由 createElement() 构建而成， 也可以使用字符串来生成“文本虚拟节点”。可选参数。如： 123456789[ '先写一些文字', createElement('h1', '一则头条'), createElement(MyComponent, &#123; props: &#123; someProp: 'foobar' &#125; &#125;)] 使用render函数的结果和我们之前使用template解析出来的结果是一样的。render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。 在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。 VNodes必须唯一组件树中的所有 VNodes 必须是唯一的。这意味着，下面的 render function 是无效的：1234567render: function (createElement) &#123; var myParagraphVNode = createElement('p', 'hi') return createElement('div', [ // 错误-重复的 VNodes myParagraphVNode, myParagraphVNode ])&#125; 如果你真的需要重复很多次的元素/组件，你可以使用工厂函数来实现。例如，下面这个例子 render 函数完美有效地渲染了 20 个相同的段落：1234567 render: function (createElement) &#123; return createElement('div', Array.apply(null, &#123; length: 20 &#125;).map(function () &#123; return createElement('p', 'hi') &#125;) )&#125; 使用JavaScript 代替模板功能只要在原生的 JavaScript 中可以轻松完成的操作，Vue 的 render 函数就不会提供专有的替代方法。比如，在 template 中使用的 v-if 和 v-for：1234&lt;ul v-if="items.length"&gt; &lt;li v-for="item in items"&gt;&#123;&#123; item.name &#125;&#125;&lt;/li&gt;&lt;/ul&gt;&lt;p v-else&gt;No items found.&lt;/p&gt; 这些都会在 render 函数中被 JavaScript 的 if/else 和 map 重写：12345678910props: ['items'],render: function (createElement) &#123; if (this.items.length) &#123; return createElement('ul', this.items.map(function (item) &#123; return createElement('li', item.name) &#125;)) &#125; else &#123; return createElement('p', 'No items found.') &#125;&#125; v-modelrender 函数中没有与 v-model 的直接对应 - 你必须自己实现相应的逻辑：1234567891011121314props: ['value'],render: function (createElement) &#123; var self = this return createElement('input', &#123; domProps: &#123; value: self.value &#125;, on: &#123; input: function (event) &#123; self.$emit('input', event.target.value) &#125; &#125; &#125;)&#125; 这就是深入底层的代价，但与 v-model 相比，这可以让你更好地控制交互细节。 事件&amp;案件修饰符对于 .passive、.capture 和 .once事件修饰符, Vue 提供了相应的前缀可以用于 on：Modifier(s) | Prefix|-|-|.passive | &amp;.capture| !.once| ~.capture.once or .once.capture | ~! 例如:12345on: &#123; '!click': this.doThisInCapturingMode, '~keyup': this.doThisOnce, '~!mouseover': this.doThisOnceInCapturingMode&#125; 对于其他的修饰符，前缀不是很重要，因为你可以在事件处理函数中使用事件方法：Modifier(s) | Equivalent in Handler|-|-|.stop | event.stopPropagation().prevent| event.preventDefault().self | if (event.target !== event.currentTarget) returnKeys: .enter, .13 | if (event.keyCode !== 13) return (change 13 to another key code for other key modifiers)Modifiers Keys: .ctrl, .alt, .shift, .meta | if (!event.ctrlKey) return (change ctrlKey to altKey, shiftKey, or metaKey, respectively)这里是一个使用所有修饰符的例子：12345678910111213141516on: &#123; keyup: function (event) &#123; // 如果触发事件的元素不是事件绑定的元素 // 则返回 if (event.target !== event.currentTarget) return // 如果按下去的不是 enter 键或者 // 没有同时按下 shift 键 // 则返回 if (!event.shiftKey || event.keyCode !== 13) return // 阻止 事件冒泡 event.stopPropagation() // 阻止该元素默认的 keyup 事件 event.preventDefault() // ... &#125;&#125; 插槽你可以通过 this.$slots 访问静态插槽的内容，得到的是一个 VNodes 数组：1234render: function (createElement) &#123; // `&lt;div&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', this.$slots.default)&#125; 也可以通过 this.$scopedSlots 访问作用域插槽，得到的是一个返回 VNodes 的函123456789props: ['message'],render: function (createElement) &#123; // `&lt;div&gt;&lt;slot :text="message"&gt;&lt;/slot&gt;&lt;/div&gt;` return createElement('div', [ this.$scopedSlots.default(&#123; text: this.message &#125;) ])&#125; 如果要用渲染函数向子组件中传递作用域插槽，可以利用 VNode 数据对象中的 scopedSlots 域：12345678910111213render: function (createElement) &#123; return createElement('div', [ createElement('child', &#123; // 在数据对象中传递 `scopedSlots` // 格式：&#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125; scopedSlots: &#123; default: function (props) &#123; return createElement('span', props.text) &#125; &#125; &#125;) ])&#125; ASTAST是指抽象语法树（abstract syntax tree），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式。Vue在mount过程中，template会被编译成AST语法树。然后，经过generate（将AST语法树转化成render function字符串的过程）得到render函数，返回VNode。 源码分析编译相关的代码都在 compiler文件中 core/instance / render.js 中 observe - 响应式_ 在js中默认为是定义的私有属性 ，建议不要多次访问 (视频2-5， 2-6)platform/util/index.js 判断是否是render 还是template new watcher() 渲染 watcher (observer/watcher.js ) # Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。它的定义在 src/core/instance/render.js 文件中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//再此定义一个render私有方法 返回一个vnode，通过vm.$options拿到render函数Vue.prototype._render = function (): VNode &#123; const vm: Component = this const &#123; render, _parentVnode &#125; = vm.$options // 复位_render标志在插槽上用于重复的插槽检查 if (process.env.NODE_ENV !== 'production') &#123; for (const key in vm.$slots) &#123; // $flow-disable-line vm.$slots[key]._rendered = false &#125; &#125; if (_parentVnode) &#123; vm.$scopedSlots = _parentVnode.data.scopedSlots || emptyObject &#125; // 设置父vnode。这允许呈现函数访问占位符节点上的数据。 vm.$vnode = _parentVnode // render self let vnode try &#123; //利用call的方法 参数一当前上下文，vm._renderProxy再生产环境下 就是vm，也就是this 本身，开发环境是一个proxy 对象 vnode = render.call(vm._renderProxy, vm.$createElement) &#125; catch (e) &#123; handleError(e, vm, `render`) // 返回错误呈现结果， // 或先前的vnode，以防止呈现错误导致空白组件 /* istanbul ignore else */ if (process.env.NODE_ENV !== 'production') &#123; if (vm.$options.renderError) &#123; try &#123; vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e) &#125; catch (e) &#123; handleError(e, vm, `renderError`) vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; else &#123; vnode = vm._vnode &#125; &#125; // 上边 会返回一个 vnode ， $options 这个函数可以自己写 ，也可以通过编译生成 // 如果呈现函数出错，返回空vnode if (!(vnode instanceof VNode)) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; Array.isArray(vnode)) &#123; warn( 'Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm ) &#125; vnode = createEmptyVNode() &#125; // set parent vnode.parent = _parentVnode return vnode&#125; 这段代码最关键的是 render 方法的调用，我们在平时的开发工作中手写 render 方法的场景比较少，而写的比较多的是 template 模板，在之前的 mounted 方法的实现中，会把 template 编译成 render 方法，但这个编译过程是非常复杂的，我们不打算在这里展开讲，之后会专门花一个章节来分析 Vue 的编译过程。 在 Vue 的官方文档中介绍了 render 函数的第一个参数是 createElement，那么结合之前的例子： 123&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt; 相当于我们编写如下 render 函数：12345678910111213var vm = new Vue(&#123; el: '#app', render (createElement) &#123; return createElement('div', &#123; attrs: &#123; id: 'app' &#125; &#125;, this.message) &#125;, data () &#123; return message: 'Hello Vue!' &#125;&#125;) 再回到 _render 函数中的 render方法的调用： 1vnode = render.call(vm._renderProxy, vm.$createElement) 可以看到，render 函数中的 createElement 方法就是 vm.$createElement 方法：123456789export function initRender (vm: Component) &#123; // ... //将createElement fn绑定到这个实例，这样我们就可以在其中获得适当的呈现上下文。 // args顺序:标签、数据、子元素、normalizationType、alwaysNormalize内部版本由模板编译的呈现函数使用 vm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false) //规范化通常应用于公共版本，用于用户编写的呈现函数。 //手写render函数 创建的方法 vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)&#125; 实际上，vm.$createElement 方法定义是在执行 initRender 方法的时候，可以看到除了 vm.$createElement 方法，还有一个 vm._c 方法，它是被模板编译成的 render 函数使用，而 vm.$createElement 是用户手写 render 方法使用的， 这俩个方法支持的参数相同，并且内部都调用了 createElement 方法。 总结 render方法的实质就是生成template模板； 通过调用一个方法来生成，而这个方法是通过render方法的参数传递给它的； 这个方法有三个参数，分别提供标签名，标签相关属性，标签内部的html内容 通过这三个参数，可以生成一个完整的模板 备注：render方法可以使用JSX语法，但需要Babel plugin插件；render方法里的第三个参数可以使用函数来生成多个组件（特别是如果他们相同的话），只要生成结果是一个数组，且数组元素都是VNode即可； 注意：render函数室友限制的，Vue.js 2.X支持，但是1.X无法使用。 vm._render最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node。Vue 2.0 相比 Vue 1.0 最大的升级就是利用了 Virtual DOM。因此在分析 createElement 的实现前，我们先了解一下 Virtual DOM 的概念。 [参考博客]vue Render函数进阶理解Vue中的Render渲染函数(一) Vue基础个人总结，条件渲染，列表渲染，组件等如何理解Vue的render函数的具体用法Vue2.x中的Render函数用jsx写vue组件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>render</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue深度学习（2）- 生命周期]]></title>
    <url>%2F2018%2F10%2F20%2Fvue-lifeCycle-2%2F</url>
    <content type="text"><![CDATA[Vue的生命周期方法 研究方向 hook机制 研究方法 各个hook在哪个阶段触发，为啥会在这个阶段触发？触发这个钩子可以改变什么或者得到什么？ 钩子函数（Hook）钩子是Windows消息处理机制的一个平台,应用程序可以在上面设置子程以监视指定窗口的某种消息；钩子机制允许应用程序截获处理window消息或特定事件，钩子函数可以理解为js运行进程中在其特定段时的回调函数 什么是生命周期？生命周期：Vue 实例从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期，各个阶段有相对应的事件钩子 图中 数据观测： 在new Vue() 时 开始观测数据 init event &amp; lifeCycle: 表示new Vue 后事件和生命周期的init 当created完成之后，它会去判断instance（实例）里面是否含有“el”option（选项），如果没有的话，它会调用vm.$mount(el)这个方法，然后执行下一步；如果有的话，直接执行下一步。紧接着会判断是否含有“template”这个选项，如果有的话，它会把template解析成一个render function ，这是一个template编译的过程，结果是解析成了render函数：123render (h) &#123; return h(&apos;div&apos;, &#123;&#125;, this.text)&#125; render函数里面的传参h就是Vue里面的createElement方法，return返回一个createElement方法，其中要传3个参数，第一个参数就是创建的div标签；第二个参数传了一个对象，对象里面可以是我们组件上面的props，或者是事件之类的东西；第三个参数就是div标签里面的内容，这里我们指向了data里面的text。 使用render函数的结果和我们之前使用template解析出来的结果是一样的。render函数是发生在beforeMount和mounted之间的，这也从侧面说明了，在beforeMount的时候，$el还只是我们在HTML里面写的节点，然后到mounted的时候，它就把渲染出来的内容挂载到了DOM节点上。这中间的过程其实是执行了render function的内容。 在使用.vue文件开发的过程当中，我们在里面写了template模板，在经过了vue-loader的处理之后，就变成了render function，最终放到了vue-loader解析过的文件里面。这样做有什么好处呢？原因是由于在解析template变成render function的过程，是一个非常耗时的过程，vue-loader帮我们处理了这些内容之后，当我们在页面上执行vue代码的时候，效率会变得更高。 beforeMount在有了render function的时候才会执行，当执行完render function之后，就会调用mounted这个钩子，在mounted挂载完毕之后，这个实例就算是走完流程了。后续的钩子函数执行的过程都是需要外部的触发才会执行。比如说有数据的变化，会调用beforeUpdate，然后经过Virtual DOM，最后updated更新完毕。当组件被销毁的时候，它会调用beforeDestory，以及destoryed。 生命周期的钩子 (lifecyclehook)Vue所有的生命周期钩子自动绑定在this上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法。这是因为箭头函数绑定了父上下文，因此this与你期待的Vue实例不同。 生命周期中的钩子函数 组建状态 最佳实践 beforeCreate 实例初始化之后,this指向创建的实例，此时还不能访问到data,computed,watch,methods上的数据和方法 常用于初始化非响应式变量 created 实例创建完成，可以访问到 data,computed,watch,methods上的数据和方法，未挂载到dom 上，不能访问#el 属性， $ref属性d额内容为空数组 常用语简单的ajax请求,页面的初始化 beforeMount 在挂载开始前被调用，beforeMount之前，会找到对应的template，并编译成render函数 - mounted 实例挂载到DOM上，此时可以通过DOM API 获取到DOM 节点，$ref 属性可以访问 常用于获取vnode信息和操作，ajax请求 beforeUpdate 响应式数据更新时调用，发生在虚拟DOM打补丁之前 适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器 updated 虚拟DOM重新渲染和打补丁之后调用，组件DOM已经更新，可执行依赖于DOM的操作 避免在这个钩子函数中操作数据，可能陷入死循环 beforeDestroy 实例销毁之前调用。这一步，实力任然完全可用，this仍能获取到实例 常用于销毁定时器，解绑迁居时间，销毁插件对象等操作 destroyed 实力销毁后调用，调用后，Vue实例只是的所有东西都会解绑，所有的事件监听器会被移除，所有的姿势里也会被销毁 在此也可以用于销毁定时器 注： created阶段的ajax请求与mounted请求的区别：前者页面视图未出现，如果请求信息过多，页面会长时间处于白屏状态，此时如果做DOM请求时会报错,页面还没有渲染出来 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick(https://blog.csdn.net/sinat_17775997/article/details/71638144) beforeCreate，created，beforeMount，mounted 是自动被调用 beforeUpdate, updated,beforeDestroy,destroyed 是手动调用 子组件的created 优先于父组件的created 执行， 父组件的beforeCreate 优先于子组件的beforeCreate 子组件的mounted优先于父组件的mounted， 父组件的beforeMount 优先于子组件的 beforeMount 子组件的destroyed优先于父组件的beforeDestroy， 父组件的beforeDestroy 优先于子组件的 beforeDestroy 最后还有 两个钩子函数没显示activated &amp; deactivated使用&lt;keep-alive&gt;会将数据保留在内存中，如果要在每次进入页面的时候获取最新的数据，需要在activated阶段获取数据，承担原来created钩子中获取数据的任务 activated： 在组件被激活时调用，在组件第一次渲染时也会被调用，之后每次keep-alive激活时被调用，该钩子在服务器端渲染期间不被调用。 deactivated： keep-alive组件停用时调用。该钩子在服务端渲染期间不被调用。 组件内的离开当前路由钩子beforeRouteLeave =&gt; 路由前置守卫 beforeEach =&gt; 全局后置钩子afterEach =&gt; deactivated 离开缓存组件 =&gt; activated 进入缓存组件(如果你进入的也是缓存路由) // 如果离开的组件没有缓存的话 beforeDestroy会替换deactivated // 如果进入的路由也没有缓存的话 全局后置钩子afterEach=&gt;销毁 destroyed=&gt; beforeCreate等 路由导航守卫Vue的钩子函数 [路由导航守卫、keep-alive、生命周期钩子] 实例demo： 见template 遗留问题： 兄弟组件通过bus传值时的updated，beforeUpdate 生命周期顺序如果是通过父级派发更新事件时，beforeUpdate，和updated的顺序 都是自上到下正常顺序进行；如果是兄弟组件的派发顺序是beforeUpdate是从上到下，updated 的顺序是从下到上的更新顺序 beforeCreate 有什么具体实际的用处，例举vue生命周期中 beforeCreate 是实例初始化完成后数据观测（data observer）和event/watcher之前被调用。 在beforeCreate前，所有的options都会先存到vm.$options中，在beforeCreate之后，将$options里的data啦，props啦，methods啦等等一个个附到vm上，然后再触发created钩子。所以在beforeCreate的时候，通过this.message是拿不到值的，在created的时候就能通过this.message拿到值了。 一定要在beforeCreate的时候就同步去拿data里的值的话，就是直接从this.$options.data里去拿。如果data中的初始值是简单的string，那直接this.$options.data()[“message”]就好.涉及到复杂点的情况，建议看看源码里是怎么处理的，具体在core/instance/state.js中的initData(vm)里。还有一种方法 可以使用nextTick()，相当于做个延迟，等页面挂载完后在执行使用promise 12345678910111213141516171819let F = null;export default &#123; //... data()&#123; return &#123; dataList:[] &#125; &#125;, beforeCreate() &#123; F = fetchData(//fetchData是取数方法 //...返回promise ) &#125;, created() &#123; F.then(data=&gt;&#123; this.dataList = data &#125;) &#125;&#125; 本人理解其中原因就是一个实例初始化后的提示功能，表示此后要开始 参考文档：如何解释vue的生命周期才能令面试官满意？vue生命周期（五）深入 Vue 生命周期Vue 实例中的生命周期钩子详解Vue.js源码解读生命周期Vue的钩子函数[路由导航守卫、keep-alive、生命周期钩子]Vue生命周期中mounted和created的区别深入理解Vue生命周期、手动挂载及挂载子组件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议认识]]></title>
    <url>%2F2018%2F09%2F05%2FThe-HTTP-protocol%2F</url>
    <content type="text"><![CDATA[http请求由三部分组成，分别是：请求行、消息报头、请求正文 HTTP（超文本传输协议）是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 常用的HTTP方法有哪些？GET、POST、PUT、HEAD、DELETE、OPTIONS GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器。 POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。 PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。 HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。 DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。 OPTIONS：查询相应URI支持的HTTP方法。 GET方法与POST方法的区别1、get重点在从服务器上获取资源，post重点在向服务器发送数据；2、get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用”?”连接，多个请求数据间用”&amp;”连接，如http://127.0.0.1/Test/login.action?name=admin&amp;password=admin，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；3、Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式4、get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高5、get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码；post支持标准字符集，可以正确传递中文字符 HTTP请求报文与响应报文格式请求报文包含三部分：a、请求行：包含请求方法、URI、HTTP版本信息b、请求首部字段c、请求内容实体 响应报文包含三部分：a、状态行：包含HTTP版本、状态码、状态码的原因短语b、响应首部字段c、响应内容实体 常见的HTTP相应状态码返回的状态 1xx：指示信息–表示请求已接收，继续处理 2xx：成功–表示请求已被成功接收、理解、接受 3xx：重定向–要完成请求必须进行更进一步的操作 4xx：客户端错误–请求有语法错误或请求无法实现 5xx：服务器端错误–服务器未能实现合法的请求 200：请求被正常处理 204：请求被受理但没有资源可以返回 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。 301：永久性重定向 302：临时重定向 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上 304：发送附带条件的请求时，条件不满足时返回，与重定向无关 307：临时重定向，与302类似，只是强制要求使用POST方法 400：请求报文语法有误，服务器无法识别 401：请求需要认证 403：请求的对应资源禁止被访问 404：服务器无法找到对应资源 500：服务器内部错误 503：服务器正忙 HTTP1.1版本新特性a、默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求 b、管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应 c、断点续传原理 常见HTTP首部字段a、通用首部字段（请求报文与响应报文都会使用的首部字段） Date：创建报文时间 Connection：连接的管理 Cache-Control：缓存的控制 Transfer-Encoding：报文主体的传输编码方式 b、请求首部字段（请求报文会使用的首部字段） Host：请求资源所在服务器 Accept：可处理的媒体类型 Accept-Charset：可接收的字符集 Accept-Encoding：可接受的内容编码 Accept-Language：可接受的自然语言 c、响应首部字段（响应报文会使用的首部字段） Accept-Ranges：可接受的字节范围 Location：令客户端重新定向到的URI Server：HTTP服务器的安装信息 d、实体首部字段（请求报文与响应报文的的实体部分使用的首部字段） Allow：资源可支持的HTTP方法 Content-Type：实体主类的类型 Content-Encoding：实体主体适用的编码方式 Content-Language：实体主体的自然语言 Content-Length：实体主体的的字节数 Content-Range：实体主体的位置范围，一般用于发出部分请求时使用 HTTP的缺点与HTTPSa、通信使用明文不加密，内容可能被窃听b、不验证通信方身份，可能遭到伪装c、无法验证报文完整性，可能被篡改 HTTPS就是HTTP加上SSL加密处理（一般是SSL安全通信线路）+认证+完整性保护 HTTP优化利用负载均衡优化和加速HTTP应用 利用HTTP Cache来优化网站 文章摘自HTTP协议【详解】——经典面试题]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于跨域的一些理解]]></title>
    <url>%2F2018%2F09%2F05%2FCross-domain%2F</url>
    <content type="text"><![CDATA[什么是跨域跨域:浏览器对于javascript的同源策略的限制,例如a.cn下面的js不能调用b.cn中的js,对象或数据(因为a.cn和b.cn是不同域),所以跨域就出现了.上面提到的,同域的概念又是什么呢??? 简单的解释就是相同域名,端口相同,协议相同 同源策略:请求的url地址,必须与浏览器上的url地址处于同域上,也就是域名,端口,协议相同.比如:我在本地上的域名是xxx.cn,请求另外一个域名一段数据这个时候在浏览器上会报错: 1Failed to load http:/xxx.cn/: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://sss.com&apos; is therefore not allowed access. 这个就是同源策略的保护,如果浏览器对javascript没有同源策略的保护,那么一些重要的机密网站将会很危险~ xxx.cn/json/jsonp/jsonp.html 请求地址 形式 结果 http://xxx.cn/test/a.html 同一域名,不同文件夹 成功 http://xxx.cn/json/jsonp/jsonp.html 同一域名,统一文件夹 成功 http://a.xxx.cn/json/jsonp/jsonp.html 不同域名,文件路径相同 失败 http://xxx.cn:8080/json/jsonp/jsonp.html 同一域名,不同端口 失败 https://xxx.cn/json/jsonp/jsonp.html 同一域名,不同协议 失败 JS跨域这里所说的JS跨域，指的是在处理跨域请求的过程中，技术面会偏浏览器端较多一些，一般是利用浏览器的一些特性进行hack处理，从而避开同源策略的限制。 JSONP由于同源策略不会阻止动态脚本的插入到文档中去，所以催生出了一种很常用的跨域方式： JSONP(JSON with Padding)。 实例创建三个文件 server.js1234567891011121314const http = require(&apos;http&apos;);const fs = require(&apos;fs&apos;);http.createServer(function (request,response) &#123; console.log(&apos;request come&apos;, request.url); const html = fs.readFileSync(&apos;test.html&apos;,&apos;utf8&apos;); // response.writeHead(200, &#123; // &apos;Content-Type&apos;: &apos;test/html&apos; // &#125;); response.end(html);&#125;).listen(8888);console.log (&apos;server listening on http://localhost:8888&apos;); server2.js123456789const http = require(&apos;http&apos;);http.createServer(function (request,response) &#123; console.log(&apos;request come&apos;, request.url); &#125;).listen(8887);console.log (&apos;server listening on http://localhost:8887&apos;); test.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; ppppp &lt;/div&gt; &lt;script&gt; var xhr = new XMLHttpRequest(); xhr.open(&apos;GET&apos;,&apos;http://127.0.0.1:8887/&apos;); xhr.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 同时启动 server.js server2.js 服务 然后按照上面代码 使用 server.js 启动 test.html 页面 但是 test.htm页面 发送一个http请求 请求的 服务器为端口8887 ,也就是 server2.js 服务 此时页面上会提示 跨域1Failed to load http://127.0.0.1:8887/: No &apos;Access-Control-Allow-Origin&apos; header is present on the requested resource. Origin &apos;http://localhost:8888&apos; is therefore not allowed access. 我们的解决方法就是 在server2.js 页面 http.createServer 的装添加一下页面1234response.writeHead(200, &#123; &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos; &#125;) response.end(&apos;123&apos;); 上边的 &#39;Access-Control-Allow-Origin&#39;: &#39;*&#39; 表示 允许跨域的 域名 ，*表示 允许一切url的跨域 ，如果只是允许 某个网站访问数据 就可以直接 写网站域名 使用jsonp的方式解决跨域 在HTML添加标签1&lt;script src=&quot;http://localhost:8887&quot;&gt;&lt;/script&gt; 这样同样 可以请求到页面的数据 所以 jsonp 的实现原理， 就是 把请求的数据以标签请求资源的方式请求 ，浏览器对资源请求不会做限制 ，就可以请求到数据 CORS跨域限制以及预请求验证cors 预请求 允许的方法 （method）GET HEAD POST 不需要预请求验证 允许的 Content-Type123text/plan multipar/form-data application、x-www-form-urlencoded 以上是在form表单做element请求的时候 允许的类型 其他限制请求头限制网页 https://fetch.spec.whatwg.org/#cors-safelisted-request-header xmlHttpRequestUpload 对象均没有注册任何时间监听器请求中没有使用ReadableStream对象如果以上都允许 服务区改为 123456response.writeHead(200, &#123; &apos;Access-Control-Allow-Origin&apos;: &apos;*&apos;, &apos;Access-Control-Allow-Headers&apos;: &apos;x-Test-Cors&apos;, //允许的请求头部 &apos;Access-Control-Allow-Methods&apos;: &apos;Delete,PUT,POST&apos;,//允许的请求方法 &apos;Access-Control-Max-Age&apos;: &apos;1000&apos; //表示多长时间内不做验证 可以直接请求数据 &#125;) http报文格式http方法是用来定义对资源的操作 get： 获取数据 post: 创建数据 put: 更新数据 delete： 删除数据 最常用的事 post、get http code定义服务器队请求的处理结果 各个区间的code有个字的语义 200 - 299 代表这个操作成功的 300 - 399 代表这个操作重定向的，用别的方式获取这个数据 400 - 499 发送的请求有问题 500 - 599 服务器的错误 好的http服务可以通过 code直接判断结果 可缓存性publichttp请求返回过程中 privateno-cache表示虽然可以缓存 ，但是下次请求还是要服务器验证 设置缓存时长 可以在加载一个js的时候 设置12&apos;Content-Type&apos;:&apos;text/javascript&apos;,&apos;Cache-Control&apos;: &apos;max-age=200, public&apos;, 这样的设置后 第二次加载页面时 如果在设置的事件内，会直接加载缓存中的文件解决方法 就是在 js后边添加hash值 每次刷新都会改变hash值 所以就会重新加载页面]]></content>
      <categories>
        <category>http</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>cross</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常见技巧汇总]]></title>
    <url>%2F2018%2F06%2F03%2FMobile-terminal-skills%2F</url>
    <content type="text"><![CDATA[前言本文是摘录整理了移动端常见的一些bug以及解决方案，第一篇，后面还会有持续的文章更新整理。 点击样式闪动 Q: 当你点击一个链接或者通过Javascript定义的可点击元素的时候，它就会出现一个半透明的灰色背景。A:根本原因是-webkit-tap-highlight-color，这个属性是用于设定元素在移动设备（如Adnroid、iOS）上被触发点击事件时，响应的背景框的颜色。建议写在样式初始化中以避免所以问题：div,input(selector) {-webkit-tap-highlight-color: rgba(0,0,0,0);}另外出现蓝色边框：outline:none； 123-webkit-tap-highlight-color : rgba (255, 255, 255, 0) ;// i.e . Nexus5/Chrome and Kindle Fire HD 7 ''-webkit-tap-highlight-color : transparent ; 屏蔽用户选择Q: 禁止用户选择页面中的文字或者图片A:代码如下123456-webkit-touch-callout: none;-webkit-user-select: none;-khtml-user-select: none;-moz-user-select: none;-ms-user-select: none;user-select: none; 移动端如何清除输入框内阴影Q: 在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭：A:代码如下-webkit-appearance: none; 禁止文本缩放Q: 禁止文本缩放A:代码如下-webkit-text-size-adjust: 100%; 如何禁止保存或拷贝图像Q: 如何禁止保存或拷贝图像A:代码如下123img&#123; -webkit-touch-callout: none;&#125; 解决字体在移动端比例缩小后出现锯齿的问题Q: 解决字体在移动端比例缩小后出现锯齿的问题A:代码如下-webkit-font-smoothing: antialiased; ####设置input里面placeholder字体的大小Q: 设置input里面placeholder字体的大小A:代码如下::-webkit-input-placeholder{ font-size:10pt;} audio元素和video元素在ios和andriod中无法自动播放Q: audio元素和video元素在ios和andriod中无法自动播放A:代码如下,触屏及播放123$('html').one('touchstart',function()&#123; audio.play()&#125;) 手机拍照和上传图片Q: 针对file类型增加不同的accept字段A:代码如下12345&lt;input type="file"&gt; //的accept 属性 &lt;!-- 选择照片 --&gt;&lt;input type=file accept="image/*"&gt;&lt;!-- 选择视频 --&gt;&lt;input type=file accept="video/*"&gt; 输入框自动填充颜色Q: 针对input标签已经输入过的，会针对曾经输入的内容填充黄色背景，这是webkit内核自动添加的，对应的属性是autocomplete,默认是on,另对应的样式是input:-webkit-autofill 且是不可更改的。A:方案如下 1 设置标签的autocomplete=”off”,亲测无效可能 2 设置盒子的内阴影为你常态的颜色（下面以白色为例） 12box-shadow:0 0 0 1000px #fff inset ;-webkit-box-shadow: 0 0 0px 1000px #fff inset; 开启硬件加速Q: 优化渲染性能A:代码如下1234-webkit-transform: translate3d(0, 0, 0);-moz-transform: translate3d(0, 0, 0);-ms-transform: translate3d(0, 0, 0);transform: translate3d(0, 0, 0); 用户设置字号放大或者缩小导致页面布局错误12345 body&#123; -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; -moz-text-size-adjust: 100% !important; &#125; 移动端去除type为number的箭头1234input::-webkit-outer-spin-button,input::-webkit-inner-spin-button&#123; -webkit-appearance: none !important; margin: 0; &#125; 实现横屏竖屏的方案css 用 css3媒体查询，缺点是宽度和高度不好控制123456789101112131415161718192021@media screen and (orientation: portrait) &#123; .main &#123; -webkit-transform:rotate(-90deg); -moz-transform: rotate(-90deg); -ms-transform: rotate(-90deg); transform: rotate(-90deg); width: 100vh; height: 100vh; /*去掉overflow 微信显示正常，但是浏览器有问题，竖屏时强制横屏缩小*/ overflow: hidden; &#125;&#125;@media screen and (orientation: landscape) &#123; .main &#123; -webkit-transform:rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); transform: rotate(0) &#125;&#125; js 判断屏幕的方向或者resize事件123456789101112131415161718192021222324var evt = "onorientationchange" in window ? "orientationchange" : "resize"; window.addEventListener(evt, function() &#123; var width = document.documentElement.clientWidth; var height = document.documentElement.clientHeight; $print = $('#print'); if( width &gt; height )&#123; $print.width(width); $print.height(height); $print.css('top', 0 ); $print.css('left', 0 ); $print.css('transform' , 'none'); $print.css('transform-origin' , '50% 50%'); &#125; else&#123; $print.width(height); $print.height(width); $print.css('top', (height-width)/2 ); $print.css('left', 0-(height-width)/2 ); $print.css('transform' , 'rotate(90deg)'); $print.css('transform-origin' , '50% 50%'); &#125; &#125;, false); 作者：RobinsonZhang链接：https://juejin.im/post/5af918636fb9a07ac5603ecb来源：掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs创建http服务]]></title>
    <url>%2F2018%2F06%2F03%2Fhttp-server%2F</url>
    <content type="text"><![CDATA[安装nodejswindow 进入官网下载安装 检查版本 12node -vnode --version 创建文件server.js文件里边输入一下内容 123456789101112131415161718// 创建http服务var app = require('http').createServer(handler)var fs = require('fs');app.listen(2222);function handler (req, res) &#123; fs.readFile(__dirname + '/index.html', function (err, data) &#123; if (err) &#123; res.writeHead(500); return res.end('Error loading index.html'); &#125; res.writeHead(200,&#123;'Content-Type':'text/html'&#125;); res.write('aaaaaaaaaaa'); res.end(data); &#125;);&#125; 上边app.listen(2222)为监听端口，数字为了与默认端口冲突，尽量不要写 80 创建一个index.html 文件 ，fs读取文件 完成后 在终端输入 1node server.js 打开浏览器 在地址栏里边输入http://localhost:2222 页面就会显示内容 HTML里边的内容 修改HTML文件或者server里边的配置，重新启动 node server.js 就会显示修改 安装supervisor为了防止我们每次修改文件后查看效果 都需要重启 服务 ，我们安装 supervisor 1npm install supervisor -g 直接执行开启服务 1supervisor server.js 我们就直接可以修改 刷新 ，无需重启服务]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli移动端px生成转rem]]></title>
    <url>%2F2018%2F06%2F03%2Fvue-px-rem%2F</url>
    <content type="text"><![CDATA[vue做移动端适配，借助px2rem 插件方便的将px单位转为了rem。 1、安装1npm install px2rem-loader lib-flexible --save 2、在项目入口文件main.js中引入lib-flexible 1import &apos;lib-flexible/flexible.js&apos; 3、在build下的 utils.js中，找到generateLoaders 方法，在这里添加 。 1234567891011121314151617const px2remLoader = &#123; loader: &apos;px2rem-loader&apos;, options: &#123; remUnit: 37.5 &#125;&#125;function generateLoaders (loader, loaderOptions) &#123; const loaders = [cssLoader, px2remLoader] if (loader) &#123; loaders.push(&#123; loader: loader + &apos;-loader&apos;, options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;)&#125; 重启项目，会发现自己设置的px被转为rem 了 以上实现转换适用于： （1）组件中编写的&lt;style&gt;&lt;/style&gt;下的css （2）从index.js或者main.js中import ‘../../static/css/reset.css’引入css （3）在组件的&lt;script type=”text/ecmascript-6″&gt; import ‘../../static/css/reset.css&#39;&lt;/script&gt;中引入css 另外的情况：（1）组件中@import “../../static/css/reset.css (可考虑上面（2）、（3）的形式引入) （2）外部样式:&lt;link rel=”stylesheet” href=”static/css/reset.css”&gt; （3）元素内部样式：style=”height: 417px; width: 550px;”]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AngularJS的模块化实现]]></title>
    <url>%2F2017%2F12%2F26%2Fangularjs-model%2F</url>
    <content type="text"><![CDATA[AngularJS的模块化实现 123&lt;div ng-sctroller='helloModule'&gt;&lt;p&gt;&#123;&#123;greeeing.text&#125;&#125;,Angular&lt;/p&gt;&lt;/div&gt; 12345678//定义一个模块var helloModule = angular.module('helloAngular', []);//创建个匿名函数//创建 controller 控制器 $scope表示告诉angular把$scope注入到里边helloModule.controller('helloNgCtrl',['$scope',function($scope)&#123; $scope.greeting = &#123; text:'hello' &#125;&#125;]) 一个完整的项目 模块之间的依赖 比如下边： 123var bookStoreApp = angular.module('bookStoreApp',['ngRoute','ngAnimate','bookStoreCtrls','bookStoreFilters','bookSXtoreServices','bookStoreDirectives']) 然后再HTML中作为启动点开始引用： 1&lt;html ng-app="bookStoreApp"&gt; 指令系统123456&lt;html ng-app='MyModule'&gt; &lt;body&gt; //定义一个自定义标签 浏览器不识 &lt;hello&gt;&lt;/hello&gt; &lt;/body&gt;&lt;/html&gt; js代码123456789var MyModule = angular.module('MyModule', []);MyModule.directive('hello',function()&#123; return &#123; restrict:'E',//模式为属性模式 template:'&lt;div&gt;Hi everyone !&lt;/div&gt;',//模板 replace:true//表示可ui替换HTML相对应的标签 &#125;&#125;])]]></content>
      <categories>
        <category>Angularjs</category>
      </categories>
      <tags>
        <tag>Angularjs</tag>
        <tag>路由</tag>
        <tag>模块</tag>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【AngularJS】解决ng-if中的ng-model值无效的问题]]></title>
    <url>%2F2017%2F12%2F25%2Fangularjs-ng-if-ng-model%2F</url>
    <content type="text"><![CDATA[与其他指令一样，ng-if指令也会创建一个子级作用域，因此，如果在ng-if指令中添加了元素，并向元素属性增加 ng-model指令，那么ng-model指令对应的作用域属性子级作用域，而并非控制器注入的$scope作用域对象，这点在进行双向数据绑定时，需要引起注意。 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt; &lt;html ng-app="myApp"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt; &lt;style&gt; .frame&#123; padding: 5px 8px; margin: 0px; font-size: 12px; width: 320px; background-color: #eee; &#125; .frame div&#123; margin: 5px 0px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div ng-controller="myCtrl" class="frame"&gt; &lt;div&gt; a 的值： &#123;&#123;a&#125;&#125; &lt;br&gt; b 的值： &#123;&#123;b&#125;&#125; &lt;/div&gt; &lt;div&gt; 普通方式： &lt;input type="checkbox" ng-model="a"&gt; &lt;/div&gt; &lt;div ng-if="!a"&gt; ngIf方式：&lt;input type="checkbox" ng-model="$parent.b"&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; angular.module('myApp', []) .controller('myCtrl', function($scope)&#123; $scope.a = false; $scope.b = false; &#125;) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在ng-if方式中，每个包含的元素都拥有自己的作用域，因此，复选框元素也拥有自己的$scope作用域。相对于控制器作用域来说，这个作用域属于一个子级作用域，所以，如果它想绑定控制器中的变量值，必须添加$parent标识，只有这样才能访问到控制器中的变量。 因此，解决ng-if中ng-model值无效的问题，主要方法就是在绑定值时添加$parent标识，或者用ng-show指令代替ng-if指令，这两种方法都可以达到同样的页面效果。 文章来源【AngularJS】解决ng-if中的ng-model值无效的问题】]]></content>
      <categories>
        <category>Angularjs</category>
      </categories>
      <tags>
        <tag>Angularjs</tag>
        <tag>ng-model</tag>
        <tag>ng-if</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化构建工具-Gulp]]></title>
    <url>%2F2017%2F09%2F29%2Fgulp%2F</url>
    <content type="text"><![CDATA[为什么要自动化自动化是把源码合并压缩，合并之后就能减少http请求 ，压缩后能减少带宽，这是移动端十分需要的 自动化工具：gulp.js优点：基于流、任务化 常用的API：src dest watch task pipe src ：读取文件和文件夹 dest：生成文件 watch：监控文件 task：定制任务 pipe：流的方式处理文件 官网： www.gulpjs.com.cn 安装gulp全局安装gulp 1cnpm install gulp -g 初始化文件 1cnpm init 当前目录 安装gulp 1cnpm install --save-dev gulp 安装gulp插件 可以 批量安装 插件之间空格 1cnpm install --save-dev gulp-clean gulp-concat gulp-connect gulp-cssmin gulp-imagemin gulp-less gulp-load-plugins gulp-uglify open gulp.js搭建环境创建文件gulpfile.js: 12345678910111213141516171819var gulp = require('gulp');var $ = require('gulp-load-plugins')();var open = require('open');var app = &#123; srcPath: 'src/', devPath: 'build/', prdPath: 'dist/'&#125;// 放置依赖gulp.task('lib', function() &#123; // 读取文件 gulp.src('bower_components/**/*.js') // 拷贝文件到： .pipe(gulp.dest(app.devPath + 'vendor')) //生产目录 .pipe(gulp.dest(app.prdPath + 'vendor'))//代码上线发布目录 .pipe($.connect.reload()); //自动刷新&#125;) 然后运行： 1gulp lib 就会出现两个文件夹 build dist ,里边是编译的文件 编译html：先创建个文件夹 src&gt;index.html 、 src&gt;view&gt;main.html 在gulpfile.js里边添加 123456gulp.task('html', function() &#123; gulp.src(app.srcPath + '**/*.html') .pipe(gulp.dest(app.devPath)) .pipe(gulp.dest(app.prdPath)) .pipe($.connect.reload());&#125;); 然后再运行 1gulp html 然后src里边的HTML文件会编译到dist/buile中 json文件json 跟上边HTML一样，在src中创建一个data文件，里边书写json文件 gulpfile.js里边添加 123456gulp.task('json', function() &#123; gulp.src(app.srcPath + 'data/**/*.json') .pipe(gulp.dest(app.devPath + 'data')) .pipe(gulp.dest(app.prdPath + 'data')) .pipe($.connect.reload());&#125;); 在执行gulp json就会在build dist 里边出现json文件 编译less 文件首先在src下创建文件src&gt;style&gt;index.less ， src&gt;style&gt;main.lessindex.less 为主要文件 里边引入外部需要的文件，index.less: 1@import 'main.less'; main.less: 1234@color:#fff;a &#123; color:@color; &#125; 编译的时候只编译index.less文件 ，然后再配置文件gulpfile.js里边添加： 12345678910gulp.task('less', function() &#123; gulp.src(app.srcPath + 'style/index.less') // 在此设置编译 less为css .pipe($.less()) .pipe(gulp.dest(app.devPath + 'css')) // 在此处设置压缩css文件 .pipe($.cssmin()) .pipe(gulp.dest(app.prdPath + 'css')) .pipe($.connect.reload());&#125;); 执行命令gulp less 就会在build里边看到编译出来为css文件 和dist里边出现的css压缩文件 js文件创建两个js文件 src&gt;script&gt;1.js src&gt;script&gt;2.js里边写一些简单测试代码在gulpfile.js里边添加 12345678910gulp.task('js', function() &#123; gulp.src(app.srcPath + 'script/**/*.js') // 合并js文件 .pipe($.concat('index.js')) .pipe(gulp.dest(app.devPath + 'js')) //压缩js .pipe($.uglify()) .pipe(gulp.dest(app.prdPath + 'js')) .pipe($.connect.reload());&#125;); 然后执行gulp js，发现在build 和dist文件家中出现了script&gt;index.js image文件图片的步骤跟上边的差不多，最后还有个压缩图片 12345678gulp.task('image', function() &#123; gulp.src(app.srcPath + 'image/**/*') .pipe(gulp.dest(app.devPath + 'image')) // 压缩图片 .pipe($.imagemin()) .pipe(gulp.dest(app.prdPath + 'image')) .pipe($.connect.reload());&#125;); 执行gulp image 为了不让每次的编译的文件重复硬性 ，就要配置一个清除 12345// 清除重复的文件gulp.task('clean', function() &#123; gulp.src([app.devPath, app.prdPath]) .pipe($.clean())&#125;); 然后每次build dist 文件会被删除 等待重新编译 我们每次看效果都需要先清除之前的，然后在一个个打包编译，这样很麻烦，所以我们就需要一个指令，只需要每次执行一次 就可以把所有的任务都执行了 如下： build12// 总任务，构建任务 打包时只要执行下边就行 gulp.task('build', ['image', 'js', 'less', 'lib', 'html', 'json']); 执行gulp build 构建本地服务器，自动刷新这样还不够 ，我们需要的是只要执行一次， 就能直接在浏览器里查看效果 而且每次更改代码自动的会编译 ，浏览器会自动刷新。 首先得先创建一个本地访问的服务器 12345678910111213141516// 启动服务器 本地环境 gulp.task('serve', ['build'], function() &#123; $.connect.server(&#123; root: [app.devPath], livereload: true, //针对高级浏览器，每次代码的更改 会自动的刷新浏览器 port: 1234 //端口 &#125;); open('http://localhost:1234'); //浏览url gulp.watch('bower_components/**/*.js', ['lib']); gulp.watch(app.srcPath + '**/*.html', ['html']); gulp.watch(app.srcPath + 'data/**/*.json', ['json']); gulp.watch(app.srcPath + 'style/index.less', ['less']); gulp.watch(app.srcPath + 'script/**/*.js', ['js']); gulp.watch(app.srcPath + 'image/**/*', ['image']);&#125;); 这个服务器需要设置本地url,端口 还需要每次刷新的文件，它调用的build 来执行，这样就实现了本地的服务搭建！ 然后我们还可以在简单一些： 1gulp.task('default', ['serve']); 安装gulp-plumber插件 1cnpm install --save-dev gulp-plumber 这个插件的作用一旦是 css，js编译的时候发生错误时 ，自动化不会停止 然后在gulpfile.js下每个编译 的task里边都添加 1.pipe($.blumer()) 接着直接执行gulp，服务器自动打开，浏览器会自动的打开页面，然后修改的文件无需刷新马上就可以在浏览器里查看，这样我们的构建环境就搭完了 ！]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript--函数及作用域总结介绍]]></title>
    <url>%2F2017%2F07%2F19%2Fjavascript-Scopes%2F</url>
    <content type="text"><![CDATA[本文是对javascript在的函数及作用域进行了详细的总结介绍，需要的朋友可以过来参考下，希望对大家有所帮助在js中使用函数注意三点： 1、函数被调用时，它是运行在他被声明时的语法环境中的；2、函数自己无法运行，它总是被对象调用的，函数运行时，函数体内的this指针指向调用该函数的对象，如果调用函数时没有明确指定该对象， this 默认指向 window ( strict 模式除外，本文不涉及 strict 模式)；3、函数是一种带有可执行代码的对象类型数据。 声明函数 1、使用 function 关键字复制代码代码如下: 123function myfun(a,b)&#123; //声明名为myfun的函数return a+b;&#125; 2、 声明匿名函数 123function(a,b)&#123; return a+b;&#125; 匿名函数自身是无法保存的，由于在js中函数是一种对象型数据，因此可以把匿名函数赋给变量来保存。123var myfun = function(a,b)&#123; return a+b;&#125; 3、使用函数构造器Function //注意首字母大写Function 是js内置的一个函数，他是所有函数对象的构造器。（其他数据对象也有自己的内置构造函数，比如Number，Object等，这些构造函数自己的构造器就是Function，因为他们都是函数）。 1var myfun = new Function('a,b','return a+b;'); 其中最后一个参数是函数体，前面的参数都是函数的形式参数名，个数不定，因为需要用字符串传参来构造，函数较长时这种写法很不方便，一般很少用，也许你会用它来构造特定的返回值从而取代 eval函数。需要注意的是，全局变量和全局函数都可以看作window对象的属性，如果存在同名的函数和变量，只能有一个生效(实际上只有一个属性)，试试下面的代码。复制代码代码如下:123456function a()&#123; alert('a');&#125;alert(window.a); //访问window对象的属性也可以省去window不写var a=1;alert(window.a); 函数和变量的声明都发生在代码解析期，不同的是，变量在解析期只声明不赋值，因此，同一个作用域内存在同名的函数和变量时，在代码运行期执行到变量赋值之 前，同名函数生效，同名变量赋值之后(用新的数据覆盖了该window对象属性原有的值)，变量生效(但是要注意，在firefox 下， 在 with 伪闭包内声明的函数，只能在声明之后才能被调用，即，firefox 的 with 内没有对函数预先声明)。复制代码代码如下:123456with(&#123;&#125;)&#123; a(); //在 firefox 下 a 是未声明 function a()&#123; console.log("function a is called") &#125; &#125; 如果同名称的函数被多次声明，后面声明的将覆盖前面声明的，如：复制代码代码如下:12345678910111213alert(func1);//弹出func1()&#123;alert(2);&#125;func1()&#123; alert(1);&#125;alert(func1); //弹出func1()&#123;alert(2);&#125;func1()&#123; //这是最后一次声明的func1，以该函数为准 alert(2);&#125;alert(func1); //弹出func1()&#123;alert(2);&#125;var func1 = function()&#123; //注意 ，这里是变量赋值，不是函数声明 alert(3);&#125;alert(func1); //弹出function()&#123;alert(3);&#125; 除了 IE8 及IE8以下的浏览器，表达式中的函数声明都会返回匿名函数，不会成功声明具名函数复制代码代码如下:123456789if(function fun()&#123;&#125;)&#123; alert(fun); // error，不会成功声明名称为 fun 的函数，但在IE8及以下的浏览器中中会成功声明一个函数 fun&#125;(function fun()&#123; &#125;);alert(fun); //error但是即使在 IE8 一下， 表达式中的具名函数也不能覆盖该作用于下同名的变量：var fun = 1; //该变量不能被函数表达式中的函数名覆盖var f = function fun()&#123;&#125;;alert(f); //function fun()&#123;&#125;;alert(fun); //1 注意区别：12345678if(fun = function ()&#123;&#125;)&#123; alert(fun); // ok，这里声明了一个变量，该变量保存了一个匿名函数&#125;//js函数是引用型的对象var a = function()&#123;&#125;;var b=a;b.x=2;alert(a.x); //2 函数的参数js函数不会检查函数调用时传入的参数个数与定义他时的形式参数个数是否一致，一般地，js函数调用时可以接收的参数个数为25个，当然不同的浏览器可能有差异，ECMAScript标准对这一点并没有规范。如果你不确定函数调用时传入了多少个参数，可以使用函数的arguments对象。arguments 有点像数组，arguments.length 为传入的参数个数，arguments[0] 是第一个参数，arguments[1]是第二个参数，类推…函数对象的length属性：这个属性很少用到，甚至很少人知道，函数的length属性就是该函数定义时的形式参数个数。复制代码代码如下:123456function myfun(a,b)&#123; alert(arguments.length); //弹出调用时实际传入的参数个数 alert(arguments[0]); //对应参数a return a+b;&#125;alert(myfun.length); //形参个数，2 arguments对象还有其他属性，比如常用的arguments.callee ，指向该函数自身。要注意：如果函数内部声明了与形参同名的子函数（同域内，变量未赋值时同名函数生效），arguments 的相应值也会被修改，但是，在作用域内使用 var 声明了同名的 变量则不会导致 arguments 的参数值被函数替换（但firefox 依然替换）。复制代码代码如下:12345678910111213141516function aa(a , b,c)&#123; //js 群的一道题 function a()&#123;&#125; console.log(a); //function a console.log(aa); //如果作用域内没有 var a ,则 arguments[0] 为 function a (friefox(version 17) 则一定是function a) console.log(arguments[0]); var a = "ee"; //注销此句，考擦 arguments[0] 将变为 a 函数 var aa = "444"; arguments = 6; console.log(a); console.log(aa); console.log(arguments);&#125;aa(1,2,3); 函数的返回值js函数使用 return 语句返回值。一切数据类型都可以作为函数的返回值(包括函数)，js函数也可以没有返回值。 四、函数调用函数自己是不会运行的，当它运行时，总是存在一个调用它的对象。默认情况下，在任何语法环境中，如果没有显式指定函数的调用对象，就是指通过window对象来调用该函数，此时，函数体内的this指针指向window对象。复制代码代码如下:12345function myfun(a,b)&#123; alert(this); return a+b;&#125;myfun(1,2); // 调用函数并传入2个参数，这2个参数分别对应形式参数a,b调用函数时，如果传入的参数个数超过形式参数，就只有用arguments加下标来接收了。 由于没有显式指定调用函数的对象，alert(this)将弹出 window对象。这种调用方法是最常见的。用于显式指定函数的调用对象方法有三个： 1、如果一个函数被赋为一个对象的属性值，这个函数只能通过该对象来访问（但并非是说该函数只能被该对象调用），通过该对象调用这个函数的方式类似以面向对象编程语言中的方法调用(实际上在js中也习惯使用方法这种称呼)。复制代码代码如下: 1234567var obj=&#123;&#125;; //定义一个对象obj.fun=function(a,b)&#123;alert(this); //弹出this指针return a+b;&#125; //对象属性值为函数alert(obj.fun);// 访问fun函数。 只能通过该对象来访问这个函数obj.fun(1,2); //通过obj对象来调用fun函数，将弹出obj对象。这种方式也称为调用obj对象的fun方法。 2、 任意指定函数的调用对象：在某个语法环境中，如果可以同时访问到函数fun和对象obj，只要你愿意，可以指定通过obj对象来调用fun函数。指定方法 有2种：call方法和apply方法。(因为window对象是浏览器环境下的顶级对象，在任何语法环境中都能访问到window对象，因此，任何函数 都可以通过window对象来调用)复制代码代码如下: 123456789101112131415161718192021222324252627function fun(a,b)&#123; alert(this); return a+b;&#125;var obj=&#123;&#125;;fun.call(obj,1,2); //通过obj对象来调用fun函数，并传入2个参数，弹出的指针为obj对象。 var obj2=&#123;&#125;;obj2.fun2 = function(a,b)&#123; //obj2对象的属性fun2是一个函数 alert(this); return a+b;&#125;;obj2.fun2.call(obj,1,2); //通过obj对象来调用obj2对象的fun2属性值所保存的函数，弹出的this指针是obj对象//比较隐蔽的方法调用：数组调用一个函数[9,function()&#123; alert(this[0]); &#125;][1]();//使用window对象调用函数下面几种方法是等价的fun(1,2);window.fun(1,2); //如果fun函数是全局函数fun.call(window,1,2);fun.call(this,1,2); //如果该句代码在全局环境下（或者被window对象调用的函数体内），因为该语法环境下的this就是指向window对象。func.call(); //如果函数不需要传参func.call(null,1,2);func.call(undefined,1,2);var name = "window";function kkk()&#123; console.log(this.name); // not ie&#125;kkk(); //windowkkk.call(kkk); //kkk 函数被自己调用了 另一种比较容易疏忽的错误是，在A 对象的方法中，执行了使用了 B 对象的方法调用，试图在 B 对象的方法里使用 this 来访问 A 对象，这在各种回调函数中比较常见，最常见的情形就是 ajax 回调函数中使用 this 。复制代码代码如下:123456789101112131415161718var obj = &#123; data:null, getData:function()&#123; $.post(url,&#123;param:token&#125;,function(dataBack)&#123; //jQuery ajax post method this.data = dataBack; //试图将服务器返回的数据赋给 obj.data ,但这里的 this 已经指向 jQuery 的 ajax 对象了 &#125;,'json'); &#125;&#125;//正确做法var obj = &#123; data:null, getData:function()&#123; var host = this; //保存 obj 对象的引用 $.post(url,&#123;param:"token"&#125;,function(dataBack)&#123; host.data = dataBack; &#125;,'json'); &#125;&#125; 3、apply方法调用：apply方法与call方法唯一不同的地方是函数传参方式不同。obj2.fun2.call(obj,1,2);改为 apply方式就是obj2.fun2.apply(obj,[1,2]);apply使用类数组方式传参，除数组外，还可以使用arguments、HTMLCollection来传参，但arguments并非数组，如： 1234567var obj=&#123;&#125;;function fun_1(x,y)&#123; function fun_2(a,b)&#123; return a+b; &#125;fun_2.apply(obj,arguments); //用fun_1的arguments对象来传参，实际上是接收了x,y&#125; apply 传参在IE8 及IE8一下的浏览器中哟2个问题在 call 和 apply 调用中，如果传入标量数据(true/false ，string，number)，函数运行时将把他们传入的基本数据包装成对象，然后把this指向包装后的对象,试试下面的代码。1234567891011function a()&#123; alert(typeof this); alert(this.constructor); alert(this);&#125;a.call(false);a.call(100);a.call('hello');//甚至可以用这个特点来传参数，但是不建议这种用法：function a()&#123; alert(1+this); &#125; //对象在运算中自动进行类型转换a.call(100); //101 4、函数作为对象构造器当函数使用 new 运算作为对象构造器运行时，this 指向新构造出对象，如果该构造函数的返回值不是 null 以外的对象，构造函数运行完毕将返回 this 指向的对象,否则返回原定义的对象。复制代码代码如下: 1234567function Fun()&#123; this.a = 1; this.b = 3; console.log(this); //&#123;a:1,b:2&#125; // return &#123;a:999&#125;; //加上此举 ,将返回 &#123;a:999&#125;&#125;var obj = new Fun(); //obj = &#123;a:1,b:2&#125; ，如果没有参数，也可以写成 var obj = new Fun; 函数作用域js的变量作用域是函数级的，在js里没有类似c语言的块级作用域。js编程环境的顶级作用域是window对象下的范围，称为全局作用域，全局作用域中的变量称为全局变量。js函数内的变量无法在函数外面访问，在函数内却可以访问函数外的变量，函数内的变量称为局部变量。js函数可以嵌套，多个函数的层层嵌套构成了多个作用域的层层嵌套，这称为js的作用域链。js作用域链的变量访问规则是：如果当前作用域内存在要访问的变量，则使用当前作用域的变量，否则到上一层作用域内寻找，直到全局作用域，如果找不到，则该变量为未声明。注意，变量的声明在代码解析期完成，如果当前作用域的变量的声明和赋值语句写在变量访问语句后面，js函数会认为当前作用域已经存在要访问的变量不再向上级作用域查找，但是，由于变量的赋值发生的代码运行期，访问的到变量将是undefined.如：复制代码代码如下: 1234567891011121314var c=1000;function out()&#123; var a=1; var b=2; function fun()&#123; alert(a); //undefined var a=10; alert(a); //10 alert(b); //2 alert(c); //1000 &#125; fun();&#125;out(); 匿名函数的调用匿名函数的使用在js很重要，由于js中一切数据都是对象，包括函数，因此经常使用函数作为另一个函数的参数或返回值。如果匿名函数没有被保存，则运行后即被从内存中释放。匿名函数的调用方式一般是直接把匿名函数放在括号内替代函数名。如：12345678910111213141516(function(a,b)&#123; return a+b;&#125;)(1,2); //声明并执行匿名函数，运行时传入两个参数：1和2//或者(function(a,b)&#123; return a+b;&#125;(1,2));//下面这种写法是错误的：function(a,b)&#123; return a+b;&#125;(1,2); 由于js中语句结束的分号可以省略，js引擎会认为`function(a,b)&#123; return a+b;&#125;`是一句语句结束，因此匿名函数只声明了没有被调用，如果语句没有传参(1,2)写成()，还会导致错误，js中空括号是语法错误。 下面这种写法是正确的。var ab = function(a,b)&#123; return a+b;&#125;(1,2); // ab=3 js 解析语法时，如果表达式出现在赋值运算或操作符运算中，是”贪婪匹配”的(尽量求值) 12345678function(t)&#123; return 1+t;&#125;(); //errorvar f = function(t)&#123; return t+1;&#125;(); // ok~ function(t)&#123;return t+1;&#125;(); //ok+ function(t)&#123;return t+1;&#125;(); //ok 如果你只是想把一个匿名函数赋给一个变量，记得在赋值语句后面加上分号，否则，如果后面跟了小括号就变成了函数调用了，尤其是小括号与函数结尾之间分隔了多行时，这种错误往往很难发现。实际开发中，匿名函数可能以运算值的方式返回，这种情况可能不容易看出，比如12345var a =1;var obj = &#123;a:2,f:function()&#123; return this.a;&#125;&#125;;(1,obj.f)(); //1 逗号表达式反悔了一个匿名函数，当这个匿名函数被调用时,函数体内的 thsi 指向 window声 明并立即运行匿名函数被称为”自执行函数“，自执行函数经常用于封装一段js代码。 由于函数作用域的特点，自执行函数内的变量无法被外部访问，放在函数内 的代码不会对外面的代码产生影响，可以避免造成变量污染。 js开发很容易造成变量污染，在开发中经常引入其他编码人员开发的代码，如果不同的编码人员定义 了同名称不同含义的全局变量或函数，便造成了变量污染，同一作用域内出现同名的变量或函数，后来的将覆盖前面的。123(function()&#123; //自己的代码.....&#125;)(); 匿名函数还可以使内存及时释放：因为变量被声明在匿名函数内，如果这些变量没有在匿名函数之外被引用，那么这个函数运行完毕，里面的变量所占据的内存就会立即释放。函数的name：在firefox等浏览器，函数有一个name属性，就是该函数的函数名，但是这个属性在IE中不存在，另外，匿名函数的name为空值。1234var a=function()&#123;&#125;alert(a.name); //undefined，a是一个存储了一个匿名函数的变量function b()&#123;&#125;alert(b.name); //b ,but undefined for IE 函数被调用时，运行在他被定义时的环境中无论函数在哪里被调用，被谁调用，都无法改变其被声明时的语法环境，这决定了函数的运行环境复制代码代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var x=99;var inerFun=null;function fun1()&#123; alert(x);&#125;function holder()&#123; var x = 100; var fun2 = fun1; inerFun = function()&#123; alert(x);&#125; fun1(); //99 fun2();//99 inerFun(); //100&#125;holder();fun1(); //99inerFun(); //100 //另一个例子：var x = 100;var y=77;var a1=&#123; x:99, xx:function()&#123; //var y=88; //如果注释这个变量，y将是全局变量的77 alert(y); //没有使用this指针，调用函数的对象无法影响y的值，函数运行时将从这里按作用域链逐级搜索取值 alert(this.x); //使用了 this 指针，调用函数的 &#125;&#125;a1.xx();a1.xx.call(window);var jj = a1.xx;jj(); //效果跟a1.xx.call(window); 一样//试试下面代码var x=99;function xb()&#123; this.x=100; this.a = (function()&#123; return this.x &#125;).call(this); //new 的时候执行了,匿名函数被 实例化的对象 调用 this.b = (function()&#123; return this.x &#125;)(); //new 的时候执行了,匿名函数被window调用 this.method = function()&#123; return this.x; &#125;&#125;var xbObj = new xb();console.log(xbObj.x);console.log(xbObj.a);console.log(xbObj.b);console.log(xbObj.method()); 注意区分调用函数的对象、函数声明时的语法环境、函数调用语句的语法环境这几个概念1、调用函数的对象(或者说函数的调用方式)决定了函数运行时函数体内的this指针指向谁2、函数声明时的语法环境决定了函数运行时的访问权限3、函数调用语句的语法环境决定了函数是否真的能够被调用及何时被调用(只有函数在某个语法环境是可见的，这个函数才能被调用)函数在运行时，产生一个 arguments 对象可以访问传入函数内的参数,arguments 有一个属性可以指向函数自身：arguments.callee.函数运行时，函数的 caller 属性可以指向本函数调用语句所在函数，比如，a函数在b函数体内被调用，则当a函数运行时，a.caller就指向了b函数，如果a 函数在全局环境中被调用则 a.caller=nullarguments 和a.caller 的值与函数的每一次调用直接关联，他们都是在函数运行时产生的，只能在函数体内访问。IE8及IE8以下浏览器中，a 函数的内的 arguments.caller( IE9之后这个属性被移除) 指向 a.caller执行时的 arguments （arguments.caller.callee === a.caller）， 字符串实时解析中的函数调用：eval()、new Function()、setTimeout()、setInterval()eval() 与 window.eval()复制代码代码如下:12345678910111213function a()&#123; console.log('out of b');&#125;function b()&#123; function a()&#123; console.log("in b"); &#125; var f = function()&#123; a(); &#125;; eval('a()'); // in b window.eval('a()'); //out of b ,ie 6\7\8 in b, ie 9 out of b (new Function('a();'))(); //out of b setTimeout('a()',1000); // out of b setTimeout(f,2000);// in b&#125;b(); eval() 中的代码执行于eval() 语句所处的作用域内：复制代码代码如下:12345678910111213141516171819202122232425262728var Objinit = function()&#123; var param = 123; return &#123; execute:function(codes)&#123; eval(codes); &#125;, setCallback:function(f)&#123; this.callback = f; &#125;, fireCallback:function()&#123; this.callback &amp;&amp; this.callback.call(this); &#125;, getParam:function()&#123; return param; &#125; &#125;&#125;;var obj = Objinit ();var param = 'outerParam';console.log(param,obj.getParam()); //outerParam 123obj.execute('param = 456');console.log(param,obj.getParam()); //outerParam 456obj.setCallback(function()&#123; eval("param = 8888")&#125;);obj.fireCallback();console.log(param,obj.getParam()); //8888 456obj.setCallback(function()&#123; eval("eval(param = 9999)")&#125;);obj.fireCallback();console.log(param,obj.getParam()); //9999 456eval() 字符串中解析出的代码运在 eval 所在的作用域，window.eval() 则是运行在顶级作用域（低版本 chrome 和 低于IE9 则同 eval()）.IE 中 ，window.execScript(); 相当于 window.eval()new Function()、setTimeout()、setInterval() 的第一个字符串参数所解析得到的代码，都是在顶级作用域执行。 函数闭包要理解函数闭包，先了解 js 的垃圾自动回收机制。number、string、boolean、undefined、null 在运算和赋值操作中是复制传值，而对象类型的数据按引用传值，js 的同一个对象型数据可能被多次引用，如果某个对象不再被引用，或者两个对象之间互相引用之外不在被第三方所引用，浏览器会自动释放其占用的内存空间。函数被引用：函数被赋为其他对象的属性值，或者函数内部定义的数据在该函数外被使用，闭包的形成基于后一种情形。复制代码代码如下:12345678var f;function fun()&#123; var a =1; f = function()&#123; return ++a;&#125;;&#125;fun(); //产生一个闭包f(); // 闭包中 a=2f(); // 闭包中 a =3 ，模拟静态变量 在 fun 内 声明的匿名函数赋给 fun 外的变量 f，该匿名函数内使用了在 fun 内声明的变量 a，于是 f可以访问 变量 a，为了维持这种访问权限(f执 行时需要访问a，但何时执行未定)， fun() 执行完毕产生的变量 a 不能被释放（除非f 中的函数被释放），于是产生了一个闭包（变量 a 被封 闭了，供 f 使用）。产生闭包的关键是，一个在函数 A内的声明的函数 B被传出 A 之外，并且 B 函数内使用了在 函数A 内生成的数据（声明或按值传参）,函数B传出函数A之外的方式有多种，如：复制代码代码如下:123456function fun()&#123; var a =1; return &#123;a:123,b:456, c: function()&#123; return ++a;&#125; &#125;;&#125;var f = fun();f.c(); //a=2 广义上来说，函数运行时都会形成闭包，没有数据在函数外被引用时，闭包的生命周期很短：函数执行完毕即释放。闭包的独立性：即使由同一个函数产生的多个闭包也是相互独立的复制代码代码如下:12345678910function fun()&#123; var a =1; return function()&#123; return ++a;&#125;;&#125;var f1 = fun(); //一份闭包var f2 = fun(); //另一份闭包alert(f1()); //2alert(f1()); //3alert(f2()); //2alert(f2()); //3 这两份闭包中的变量 a 是不同的数据，每产生一份闭包， fun() 执行了一次， 变量声明语句也执行了一次。js oop 编程中闭包可以用于模拟私有成员、构造单体类复制代码代码如下:123456789101112131415161718192021222324function MakeItem(name,val)&#123; var myName,myVal; //私有属性 //私有方法 function setName(name)&#123; myname=name; &#125; //私有 方法 function setVal(val)&#123; myVal=val; &#125; //执行new构造对象时调用内部私有方法 setName(name); setVal(val); //公共方法 this.getName=function()&#123; return myName; &#125; this.getVal=function()&#123; return myVal; &#125;&#125;var obj = new MakeItem("name",100);obj.myname; //undefined 无法在外面访问私有属性obj.getName(); //ok 下面是一种单体类构建方法复制代码代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778var Singleton = (function()&#123; var instance = null; //在闭包中保存单体类的实例 var args = null; var f = function()&#123; if(!instance)&#123; if(this===window)&#123; args = Array.prototype.slice.call(arguments,0); instance = new arguments.callee(); &#125;else&#123; this.init.apply(this,args||arguments); instance = this; &#125; &#125; return instance; &#125;; f.prototype = &#123; init:function(a,b,c)&#123; this.a = a; this.b = b; this.c = c; this.method1 = function()&#123; console.log("method 1"); &#125;; this.method1 = function()&#123; console.log("method 1"); &#125;; console.log("init instance"); &#125; &#125;; f.prototype.constructor = f.prototype.init; return f; &#125;)();//单体的使用var obj1 = Singleton(1,2,3);var obj2 = new Singleton();var obj3 = new Singleton();console.log(obj1===obj2,obj2===obj3); //trueconsole.log(obj1);//一个单体类声明函数var SingletonDefine= function(fun)&#123; return (function()&#123; var instance = null; var args = null; var f = function()&#123; if(!instance)&#123; if(this===window)&#123; args = Array.prototype.slice.call(arguments,0); instance = new arguments.callee(); &#125;else&#123; fun.apply(this,args||arguments); instance = this; &#125; &#125; return instance; &#125;; f.prototype = fun.prototype; f.prototype.constructor = fun; return f; &#125;)();&#125;;var fun = function(a,b,c)&#123; this.a = a; this.b = b; this.c = c; this.method1 = function()&#123; console.log("method 1"); &#125;; console.log("init instance");&#125;;fun.prototype.method2 = function()&#123; console.log('method 2'); &#125;;//单体类声明函数用法var Singleton = SingletonDefine(fun);var obj1 = Singleton(8,9,10);var obj2 = new Singleton();var obj3 = new Singleton(3,2,1);console.log(obj1===obj2,obj2===obj3);console.log(obj1);//console.log(obj1.toSource()); //firefoxobj1.method1();obj1.method2(); IE6 的内存泄露与闭包在IE 6 中，非原生js对象（DOM 等）的循环引用会导致内存泄露，使用闭包时如果涉及非 js 原生对象引用时要注意。12345function fun()&#123; var node = document.getElementById('a'); node.onclick = function()&#123; alert(node.value); &#125;;node = null; //打断循环引用防止内存泄露 node 保存的是 DOM 对象，DOM对象存在于fun 之外(并且一直存在，即使删除也只是从文档树移出)，fun 执行后产生闭包，也构成DOM对象与回调函数的循环引用（node-function-node），在IE 6 下发生内存泄露。 您可能感兴趣的文章: 关于javascript 回调函数中变量作用域的讨论JavaScript的变量作用域深入理解网易JS面试题与Javascript词法作用域说明JavaScript中的作用域链和闭包深入Javascript函数、递归与闭包(执行环境、变量对象与作用域链)使用详解深入理解JavaScript高级之词法作用域和作用域链深入理解Javascript中this的作用域浅谈Javascript变量作用域问题javascript作用域问题实例分析]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery的deferred对象使用详解]]></title>
    <url>%2F2017%2F06%2F16%2FjQuery-Deferred%2F</url>
    <content type="text"><![CDATA[什么是deferred对象？开发网站的过程中，我们经常遇到某些耗时很长的javascript操作。其中，既有异步的操作（比如ajax读取服务器数据），也有同步的操作（比如遍历一个大型数组），它们都不是立即能得到结果的。通常的解决方法是，为它们指定回调函数（callback）。即事先规定，一旦它们运行结束，应该调用哪些函数。但是，在回调函数方面，jQuery的功能非常弱。为了改变这一点，jQuery开发团队就设计了deferred对象。简单说，deferred对象就是jQuery的回调函数解决方案。 在英语中，defer的意思是”延迟”，所以deferred对象的含义就是”延迟”到未来某个点再执行。它解决了如何处理耗时操作的问题，对那些操作提供了更好的控制，以及统一的编程接口。它的主要功能，可以归结为四点。下面我们通过示例代码，一步步来学习。 ajax操作的链式写法jQuery的ajax操作，传统写法是这样的：1234567891011121314 $.ajax(&#123; url: &quot;test.html&quot;, success: function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;, error:function()&#123; alert(&quot;出错啦！&quot;); &#125; &#125;); 在上面的代码中，$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。 $.ajax()操作完成后，如果高于1.5.0版本，返回的是deferred对象，可以进行链式操作。 新的写法是这样的： 123456 $.ajax(&quot;test.html&quot;) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 可以看到，done()相当于success方法，fail()相当于error方法。采用链式写法以后，代码的可读性大大提高。 指定同一操作的多个回调函数deferred对象的一大好处，就是它允许你自由添加多个回调函数。 还是以上面的代码为例，如果ajax操作成功后，除了原来的回调函数，我还想再运行一个回调函数，怎么办？ 很简单，直接把它加在后面就行了。 1234567 $.ajax(&quot;test.html&quot;) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;);&#125; ) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125; ) .done(function()&#123; alert(&quot;第二个回调函数！&quot;);&#125; ); 回调函数可以添加任意多个，它们按照添加顺序执行。 为多个操作指定回调函数deferred对象的另一大好处，就是它允许你为多个事件指定一个回调函数，这是传统写法做不到的。 请看下面的代码，它用到了一个新的方法$.when()：12345 $.when($.ajax(&quot;test1.html&quot;), $.ajax(&quot;test2.html&quot;)) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 这段代码的意思是，先执行两个操作$.ajax(&quot;test1.html&quot;)和$.ajax(&quot;test2.html&quot;)，如果成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。 普通操作的回调函数接口（上）deferred对象的最大优点，就是它把这一套回调函数接口，从ajax操作扩展到了所有操作。也就是说，任何一个操作—-不管是ajax操作还是本地操作，也不管是异步操作还是同步操作----都可以使用deferred对象的各种方法，指定回调函数。 我们来看一个具体的例子。假定有一个很耗时的操作wait： 123456789101112 var wait = function()&#123; var tasks = function()&#123; alert(&quot;执行完毕！&quot;); &#125;; setTimeout(tasks,5000); &#125;; 我们为它指定回调函数，应该怎么做呢？ 很自然的，你会想到，可以使用$.when()：12345 $.when(wait()) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 但是，有一个问题。$.when()的参数只能是deferred对象，所以必须对wait进行改写，所以我们需要手动新建一个deferred对象：1234567891011121314151617 var dtd = $.Deferred(); // 新建一个deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert(&quot;执行完毕！&quot;); dtd.resolve(); // 改变deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise();//返回promise对象 &#125;; 这里有两个地方需要注意。 首先，最后一行不能直接返回dtd，必须返回dtd.promise()。原因是jQuery规定，任意一个deferred对象有三种执行状态—-未完成，已完成和已失败。如果直接返回dtd，$.when()的默认执行状态为”已完成”，立即触发后面的done()方法，这就失去回调函数的作用了。dtd.promise()的目的，就是保证目前的执行状态—-也就是”未完成”—-不变，从而确保只有操作完成后，才会触发回调函数。 其次，当操作完成后，必须手动改变Deferred对象的执行状态，否则回调函数无法触发。dtd.resolve()的作用，就是将dtd的执行状态从”未完成”变成”已完成”，从而触发done()方法。 最后别忘了，修改完wait之后，调用的时候就必须直接传入dtd参数。12345 $.when(wait(dtd)) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 上面的代码有一些问题，就是dtd对象是暴露在全局的，所以我们可以通过在全局进行dtd.resolve()来提前回调。 为了避免这种情况，jQuery提供了deferred.promise()方法，它的作用是，在原来的deferred对象上返回另一个deferred对象，后者只开放与改变执行状态无关的方法（比如done方法和fail方法）屏蔽与改变执行状态有关的方法（比如resolve和reject方法）。 1234567891011121314151617181920212223242526var dtd = $.Deferred(); // 新建一个Deferred对象var wait = function(dtd)&#123; var tasks = function()&#123; alert(&quot;执行完毕！&quot;); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象&#125;;var d = wait(dtd); // 新建一个d对象，改为对这个对象进行操作$.when(d) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;);d.resolve(); // 此时，这个语句是无效的 当然，我们也可以把dtd包在函数内：12345678910111213var wait = function(dtd)&#123; var dtd = $.Deferred(); //在函数内部，新建一个Deferred对象 var tasks = function()&#123; alert(&quot;执行完毕！&quot;); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); // 返回promise对象&#125;;$.when(wait()) .done(function()&#123; alert(&quot;哈哈，成功了！&quot;); &#125;) .fail(function()&#123; alert(&quot;出错啦！&quot;); &#125;); 普通操作的回调函数接口（中）除了使用$.when()为普通操作添加回调函数，还可以使用deferred对象的建构函数$.Deferred()。 这时，wait函数还是保持不变，我们直接把它传入$.Deferred(),完整代码： 123456789101112131415161718192021 var wait = function(dtd)&#123; var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); return dtd.promise(); &#125;; $.Deferred(wait) .done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;); jQuery规定，$.Deferred()可以接受一个函数作为参数，该函数将在$.Deferred()返回结果之前执行。并且，$.Deferred()所生成的Deferred对象将作为这个函数的默认参数。 普通操作的回调函数接口（下）除了上面两种方法以外，我们还可以直接在wait对象上部署deferred接口。 1234567891011121314151617181920212223 var dtd = $.Deferred(); // 生成Deferred对象 var wait = function(dtd)&#123; var tasks = function()&#123; alert("执行完毕！"); dtd.resolve(); // 改变Deferred对象的执行状态 &#125;; setTimeout(tasks,5000); &#125;; dtd.promise(wait); wait.done(function()&#123; alert("哈哈，成功了！"); &#125;) .fail(function()&#123; alert("出错啦！"); &#125;); wait(dtd); 这里的关键是dtd.promise(wait)这一行，它的作用就是在wait对象上部署Deferred接口。正是因为有了这一行，后面才能直接在wait上面调用done()和fail()。 小结：deferred对象的方法前面已经讲到了deferred对象的多种方法，下面做一个总结： $.Deferred()生成一个deferred对象。 deferred.done()指定操作成功时的回调函数 deferred.fail()指定操作失败时的回调函数 deferred.promise()没有参数时，作用为保持deferred对象的运行状态不变；接受参数时，作用为在参数对象上部署deferred接口。 deferred.resolve()手动改变deferred对象的运行状态为”已完成”，从而立即触发done()方法。 $.when()为多个操作指定回调函数。 除了这些方法以外，deferred对象还有三个重要方法，上面的教程中没有涉及到。 deferred.then() 有时为了省事，可以把done()和fail()合在一起写，这就是then()方法。 123 $.when($.ajax( &quot;/main.php&quot; )) .then(successFunc, failureFunc ); 如果then()有两个参数，那么第一个参数是done()方法的回调函数，第二个参数是fail()方法的回调方法。如果then()只有一个参数，那么等同于done()。 deferred.reject() 这个方法与deferred.resolve()正好相反，调用后将deferred对象的运行状态变为”已失败”，从而立即触发fail()方法。 deferred.always() 这个方法也是用来指定回调函数的，它的作用是，不管调用的是deferred.resolve()还是deferred.reject()，最后总是执行。 123$.ajax( &quot;test.html&quot; ) .always( function() &#123; alert(&quot;已执行！&quot;);&#125; ); 本文转自网络，侵删。]]></content>
      <categories>
        <category>jQuery</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
        <tag>$.Deferred()</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js仿jquery一些常用方法]]></title>
    <url>%2F2017%2F05%2F07%2FNative-JS-imitation-jQuery%2F</url>
    <content type="text"><![CDATA[之前在网上发现这篇文章，觉得挺不错的，现在就分享给大家，也给大家做个参考。侵删！ 最近迷上了原生js，能不用jquery等框架的情况都会手写一些js方法，记得刚接触前端的时候为了选择器而使用jquery。。。现在利用扩展原型的方法实现一些jquery函数： 显示/隐藏12345678910//hide() Object.prototype.hide = function()&#123; this.style.display="none"; return this; &#125; //show() Object.prototype.show = function()&#123; this.style.display="block"; return this; &#125; return this的好处在于链式调用。 滑动 省略speed和callback的传入，因为要加一串判断和处理回调，代码量大12345678910111213141516171819202122//slideDown() Object.prototype.slideDown = function()&#123; this.style.display = 'block'; if(this.clientHeight&lt;this.scrollHeight)&#123; this.style.height=10+this.clientHeight+"px"; var _this = this; setTimeout(function()&#123;_this.slideDown()&#125;,10) &#125;else&#123; this.style.height=this.scrollHeight+"px"; &#125; &#125; //slideUp() Object.prototype.slideUp = function()&#123; if(this.clientHeight&gt;0)&#123; this.style.height=this.clientHeight-10+"px"; var _this = this; setTimeout(function()&#123;_this.slideUp()&#125;,10) &#125;else&#123; this.style.height=0; this.style.display = 'none'; &#125; &#125; 捕获/设置12345678910111213141516171819202122232425262728//attr() Object.prototype.attr = function()&#123; if(arguments.length==1)&#123; return eval("this."+arguments[0]); &#125;else if(arguments.length==2)&#123; eval("this."+arguments[0]+"="+arguments[1]); return this; &#125; &#125; //val() Object.prototype.val = function()&#123; if(arguments.length==0)&#123; return this.value; &#125;else if(arguments.length==1)&#123; this.value = arguments[0]; return this; &#125; &#125; //html() Object.prototype.html = function()&#123; if(arguments.length==0)&#123; return this.innerHTML; &#125;else if(arguments.length==1)&#123; this.innerHTML = arguments[0]; return this; &#125; &#125; //text()需要在html()结果基础上排除标签，会很长，省略 CSS方法 123456789//css() Object.prototype.css = function()&#123; if(arguments.length==1)&#123; return eval("this.style."+arguments[0]); &#125;else if(arguments.length==2)&#123; eval("this.style."+arguments[0]+"='"+arguments[1]+"'"); return this; &#125; &#125; 添加元素 1234567891011121314151617181920//append() Object.prototype.append = function(newElem)&#123; this.innerHTML += newElem; return this; &#125; //prepend() Object.prototype.prepend = function(newElem)&#123; this.innerHTML = arguments[0] + this.innerHTML; return this; &#125; //after() Object.prototype.after = function(newElem)&#123; this.outerHTML += arguments[0]; return this; &#125; //before() Object.prototype.before = function(newElem)&#123; this.outerHTML = arguments[0] + this.outerHTML; return this; &#125; 删除/替换元素1234567891011//empty() Object.prototype.empty = function()&#123; this.innerHTML = ""; return this; &#125; //replaceWith() Object.prototype.replaceWith = function(newElem)&#123; this.outerHTML = arguments[0]; return this; &#125; //remove() js自带，省略。 设置css类123456789101112131415161718//hasClass() Object.prototype.hasClass = function(cName)&#123; return !!this.className.match( new RegExp( "(\\s|^)" + cName + "(\\s|$)") ); &#125; //addClass() Object.prototype.addClass = function(cName)&#123; if( !this.hasClass( cName ) )&#123; this.className += " " + cName; &#125; return this; &#125; //removeClass() Object.prototype.removeClass = function(cName)&#123; if( this.hasClass( cName ) )&#123; this.className = this.className.replace( new RegExp( "(\\s|^)" + cName + "(\\s|$)" )," " ); &#125; return this; &#125; 上面的设置CSS类也可以利用html5新API classList及contains实现 但不兼容IE8以下及部分火狐浏览器 123456789101112131415Object.prototype.hasClass = function(cName)&#123; return this.classList.contains(cName) &#125; Object.prototype.addClass = function(cName)&#123; if( !this.hasClass( cName ) )&#123; this.classList.add(cName); &#125; return this; &#125; Object.prototype.removeClass = function(cName)&#123; if( this.hasClass( cName ) )&#123; this.classList.remove(cName); &#125; return this; &#125; 选择器12345678910111213141516171819//id或class选择器$("elem") function $(strExpr)&#123; var idExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|#([\w-]*))$/; var classExpr = /^(?:\s*(&lt;[\w\W]+&gt;)[^&gt;]*|.([\w-]*))$/; if(idExpr.test(strExpr))&#123; var idMatch = idExpr.exec(strExpr); return document.getElementById(idMatch[2]); &#125;else if(classExpr.test(strExpr))&#123; var classMatch = classExpr.exec(strExpr); var allElement = document.getElementsByTagName("*"); var ClassMatch = []; for(var i=0,l=allElement.length; i&lt;l; i++)&#123; if(allElement[i].className.match( new RegExp( "(\\s|^)" + classMatch[2] + "(\\s|$)") ))&#123; ClassMatch.push(allElement[i]); &#125; &#125; return ClassMatch; &#125; &#125; 需要强调的是，选择器返回的结果或结果集包含的是htmlDOM，并非jquery的对象。大多数人都知道，document.getElementById(“id”)等价于jquery$(“#id”)[0]，另外上面class选择器选择的结果如需使用，需要利用forEach遍历： 123$(".cls").forEach(function(e)&#123; e.css("background","#f6f6f6") &#125;) 遍历 siblings()和children()获取的结果也需要结合forEach使用1234567891011121314151617181920212223242526272829303132//siblings() Object.prototype.siblings = function()&#123; var chid=this.parentNode.children; var eleMatch = []; for(var i=0,l=chid.length;i&lt;l;i++)&#123; if(chid[i]!=this)&#123; eleMatch.push(chid[i]); &#125; &#125; return eleMatch; &#125; //children() 原生js已含有该方法，故命名为userChildren。 Object.prototype.userChildren = function()&#123; var chid=this.childNodes; var eleMatch = []; for(var i=0,l=chid.length;i&lt;l;i++)&#123; eleMatch.push(chid[i]); &#125; return eleMatch; &#125; //parent() Object.prototype.parent = function()&#123; return this.parentNode; &#125; //next() Object.prototype.next = function()&#123; return this.nextElementSibling; &#125; //prev() Object.prototype.prev = function()&#123; return this.previousElementSibling; &#125; jquery事件函数原生js已有，另外，原生js实现jquery的一个常用函数 ajax 将会在下一篇写道。 原生js实现ajax方法如下是一个比较完整的ajax() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849function ajax()&#123; var ajaxData = &#123; type:arguments[0].type || "GET", url:arguments[0].url || "", async:arguments[0].async || "true", data:arguments[0].data || null, dataType:arguments[0].dataType || "text", contentType:arguments[0].contentType || "application/x-www-form-urlencoded", beforeSend:arguments[0].beforeSend || function()&#123;&#125;, success:arguments[0].success || function()&#123;&#125;, error:arguments[0].error || function()&#123;&#125; &#125; ajaxData.beforeSend() var xhr = createxmlHttpRequest(); xhr.responseType=ajaxData.dataType; xhr.open(ajaxData.type,ajaxData.url,ajaxData.async); xhr.setRequestHeader("Content-Type",ajaxData.contentType); xhr.send(convertData(ajaxData.data)); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if(xhr.status == 200)&#123; ajaxData.success(xhr.response) &#125;else&#123; ajaxData.error() &#125; &#125; &#125; &#125; function createxmlHttpRequest() &#123; if (window.ActiveXObject) &#123; return new ActiveXObject("Microsoft.XMLHTTP"); &#125; else if (window.XMLHttpRequest) &#123; return new XMLHttpRequest(); &#125; &#125; function convertData(data)&#123; if( typeof data === 'object' )&#123; var convertResult = "" ; for(var c in data)&#123; convertResult+= c + "=" + data[c] + "&amp;"; &#125; convertResult=convertResult.substring(0,convertResult.length-1) return convertResult; &#125;else&#123; return data; &#125; &#125; 使用格式跟jquery的ajax差不多：123456789101112131415ajax(&#123; type:"POST", url:"ajax.php", dataType:"json", data:&#123;"val1":"abc","val2":123,"val3":"456"&#125;, beforeSend:function()&#123; //some js code &#125;, success:function(msg)&#123; console.log(msg) &#125;, error:function()&#123; console.log("error") &#125; &#125;)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于webpack和Vue搭建基础开发环境]]></title>
    <url>%2F2017%2F04%2F24%2FVue-webpack%2F</url>
    <content type="text"><![CDATA[安装nodejs windows可以直接下载， 下载链接：https://nodejs.org/zh-cn/ 下载完后查看版本： 1node --version 确认版本在6.0以上 为了下载速度更快，可以选择安装淘宝 NPM 镜像cnpm。 注：以下命令有全局标志-g 安装 Vue 这里我们选择Vue版本为2.2.6 1$ npm install vue@2.2.6 安装vue-cli vue-cli 是vue.js的脚手架，用于自动生成vue.js模板工程的。 12#全局安装 vue-cli$ npm install --global vue-cli 创建项目 创建一个基于 webpack 模板的新项目my-project 1$ vue init webpack my-project 进入项目目录 12#进入项目目录$ cd my-project 安装依赖 安装依赖模块 12# 安装依赖$ npm install 给生产环境装的依赖 1$ npm install vuex vue-router axios qs --save 安装vue运行依赖1.vuex2.vue-router3.axios 4.qs 给开发环境安装的依赖安装sass预编译环境 1npm install node-sass sass-loader --save-dev 1.node-sass2.sass-loader 运行项目 12# 运行项目$ npm run dev 之后页面会出现以下界面，恭喜你，项目环境搭建成功! 然后就可以在这开始我们的项目了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack项目流程学习（二）]]></title>
    <url>%2F2017%2F04%2F11%2Fwebpack-2%2F</url>
    <content type="text"><![CDATA[本文只是作为学习webpack入门所作的笔记，仅供参考。阅读本文之前，请首先阅读webpack项目流程学习（一）； 项目测试我们试做一个项目测试,适用laoder 以及其特性处理项目中的资源文件； 重新配置文件配置目录为下 文件中内容为： layer.html123&lt;div class="layer"&gt; &lt;div&gt;this is a layer&lt;/div&gt;&lt;/div&gt; layer.js 123456789//import tpl from './layer.html';function layer ()&#123; return &#123; name:'layer', tpl:tpl &#125;&#125;export default layer; layer.less 12345678910.layer &#123; width: 600px; height: 400px; background-color: #ff0; .&gt;div&#123; width: 600px; height: 300px; background-color: #f00; &#125;&#125; app.js 引入 layer.js文件 执行123456import layer from './components/layer/layer.js';const App = function ()&#123;console.log(layer);&#125;new App(); 使用babel-loader转换ES6使用babel 把es6的语法解析成浏览器支持的语法 首先需要安装需要支持的loader插件 安装loader 和 core 的插件 1npm install --save-dev babel-loader babel-core 安装 babel-preset-latest 1npm install --save-dev babel-preset-latest webpack.config.js 12345678910111213141516171819202122232425262728var htmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry:'./src/app.js', output:&#123; path:'./dist', filename:'js/[name].bundle.js', &#125;, module:&#123; loader:[ &#123; test:/\.js/, loader:'babel-loader', query:&#123; presets:['lastest']//告诉babel 执行js的 &#125; &#125; ] &#125;, plugins:[ new htmlWebpackPlugin(&#123; filename:'index.html', template:'index.html', inject:'body', &#125;) ]&#125; 配置文件设置 entry, output以及module 模块 ，模块打包 的loader的打包工具以及执行js的版本 123// query:&#123;// presets:['lastest']//告诉babel 执行js的// &#125; 上边的代码也可以设置在package.json 中为（作用相同）：123"babel":&#123; "presets":["latest"] &#125;, 说明： 使配置告诉webpack，处理文件通过babel-loader，并且 处理是以 &#39;presets&quot;:[&quot;latest&quot;]&#39; 版本 现在 执行一下 npm run webpack 会在dist 文件中生成index.html和js下的 main.bundle.js 文件 在浏览器打开 在console 下会显示： 123456function layer()&#123; return &#123; name:&apos;layer&apos;, tpl:tpl &#125;;&#125; 表示页面 顺利执行 打开，我们可以在修改html app.js layer.js里边的文件 执行 都可以显示出效果 选择性打包为了加快打包执行的速度 ，选择性打包，我么可以在module 中设置 参数 ： 12exclude:&apos;./node_modules/&apos;,//不包含打包的范围 优化打包速度include:&apos;./src&apos;,//包含打包的范围 优化打包速度 此时 虽然include 加快了速度 , 但是 exclude 却没有起作用 ，这时我们需要把之前的路径改为绝对路径：12include:path.resolve(__dirname,&apos;src/&apos;),exclude:path.resolve(__dirname,&apos;node_modules/&apos;), 这样就加快了执行命令的速度 使用打包css首先 要安装 css-loader 和 style-loader 1npm i style-loader css-loader --save-dev 然后在src--&gt;css下边 新建common.css文件，在里边书写一些样式 便于观察 ，然后在app.js中头部引用common.css文件 1import &apos;./css/common.css&apos;; 在配置文件 webpack.config.js中的module下添加 css loader: 12345,&#123; test:/\.css$/, loader:&apos;style-loader!css-loader&apos;&#125; 执行命令npm run webpack，打开浏览器 可以看见浏览器内联样式 css 后处理平时写样式我们不只局限与css ,有时会写预加载样式 如sass,less,以及为了浏览器兼容，我们需要添加前缀，此时我们只要 安装一个postcss-loader 就可以实现 自动添加 浏览器前缀 -webkit- ，-moz-，-ms-,-o-;相关参数可以查看postcss-loader 首先下载postcss-loader1npm install postcss-loader --save-dev 然后安装添加前缀插件autoprefixer1npm install autoprefixer --save-dev 然后在loader 后边添加!postcss-loader (loader 是从右到左加载的) 1.添加 autopredixer ，在 module 后边 添加postcss(此方法以失败) 2.首先 引入webpack(参考imooc下边评论) 1var webpack = require('webpack'); 在plugin下边添加12345678910,new webpack.LoaderOptionsPlugin(&#123; options: &#123; postcss: [ require("autoprefixer")(&#123; browsers: ["last 5 versions"] &#125;) ] &#125;&#125;) 如果css 页面有引入文件 @import，如：1@import &quot;./flex.css&quot;; 则需要在配置文件的 loader处设置处理：1loader:&apos;style-loader!css-loader?importLoaders=1!postcss-loader&apos; 其中=后边的1表示有1个引入文件 ，如果需要引入多少个文件，则设置数字为引入的数量 处理.less/.sass文件在项目中处理.less文件时，首先需要下载安装less-loader 1npm install less-loader --save-dev 如果本机没有less 支持，则需要首先安装less1npm install less 安装完成后 可以在module 设置 loader 12345,&#123; test:/\.less$/, loader:&apos;style!css!postcss!less&apos;&#125; 注意 postcss需放在css! 与less之间 以上的less 同样可以适用 @import与postcss 的后处理 输出的文件同样添加了前缀 sass 的原理与less 相同 只需要把less改为sass 即可 注意：安装 sass-loader 时 需要安装 node-sass （建议vpn安装，或者使用淘宝镜像） 1npm install node-sass/node-less 处理项目中的模板文件使webpack把模板文件当做一个字符串处理 首先 安装HTML的模块 ： html-loader 1npm install html-loader --save-dev 在 layer.js中 引入layer.html文件 1import tpl from &quot;./layer.html&quot;; 在app.js引入layer.js 文件，在在HTML中输出 1234567891011121314import Layer from &apos;./ components/layer/layer.js&apos;;const App = function ()&#123; console.log(Layer); var dom = document.getElementById(&apos;#app&apos;); var layer = new Layer(); dom.innerHTML = layer.tpl;//引入 layer.js 中 的tpl&#125;new App(); 在index.html中添加#app标签 现在 执行 命令npm run webpack 在浏览器就可以看见layer模板的 文件，此时 任意更改模板文件都可以 如果我们使用模板文件.ejs的文件 怎么可以先安装ejs-loader 模板引擎 1npm install ejs-loader --save-dev 然后我们在loader里边添加 ejs-loader12345, &#123; test:/\.ejs/, loader:&apos;ejs-loader&apos;&#125; 然后 我们可以在.ejs书写ejs代码 1234567&lt;div class=&quot;layer&quot;&gt; &lt;div&gt;this is &lt;%= name %&gt; layer&lt;/div&gt; &lt;% for(var i = 0;i&lt;arr.length;i++)&#123; %&gt; &lt;%=arr[i]%&gt; &lt;%&#125; %&gt;&lt;/div&gt; 此时 在layer.js里边引入的文件应该改为.ejs的模板文件 在app.js 文件中可以插入js调用参数 1234dom.innerHTML = layer.tpl(&#123; name:&apos;john&apos;, arr:[&apos;apple&apos;,&apos;xiaomi&apos;,&apos;oppo&apos;]&#125;); 此时运行命令后，在浏览其里边就可以看见模板代码的引入和js代码的计算结果 也可以书写.tpl后缀的格式的模板文件 处理图片以及其他文件首先先安装图片loader 1. file-loader（查看相关资料可看官网 ）1npm install file-loader --save-dev 在配置文件中 进行loader配置： 12345,&#123;//loader img test:/\.(png|jpg|gif|svg)$/, loader:&apos;file-loader&apos;&#125; 把所有的图片格式包含里边 然后在 css/less/sass中引入图片文件背景时 ，可以使用绝对路径、设置的cdn路径、也可以直接使用相对路径 123&#123; background-image: url(../../assets/1.jpg);&#125; 在 index.html 中也可以直接引用 1&lt;img src=&quot;./src/assets/1.jpg&quot; alt=&quot;&quot;&gt; 但是在模板文件中就不能直接使用相对路径，我们做一些 修改，可以像是nodes.js那样引入文件 在图片src中以这种形式添加图片： 1&lt;img src="$&#123; require('文件的相对路径') &#125;" alt&gt; 如： 1&lt;img src="$&#123; require('../../assets/1.jpg') &#125;" alt=""&gt; 然后打开生成的文件 就会看见引入的图片了 为了使图片能同意在一个图片文件夹中，我们可以设置query值 name在file-loader中设置 路径为： 图片文件夹名/图片名称-5位hash值.文件格式 12345678,&#123;//loader img test:/\.(png|jpg|gif|svg)$/, loader:&apos;file-loader&apos;, query:&#123; name:&apos;assets/[name]-[hash:5].[ext]&apos; &#125;&#125; 2. url-loader类似于file-loader , 都可以处理图片以及文件 ，但是我们可以指定一个limit ，当处理时文件/图片大小大于limit设定后，会把文件交于file-loader 处理，小于指定的大小后，则会把图片/文件处理成base:64位的编码安装 url-loader 1npm install url-loader --save-dev 测试：我们把刚才的file-loader 改为url-loader ,在query中添加一个limit值，设置limit大小123456789,&#123;//loader img test:/\.(png|jpg|gif|svg)$/, loader:&apos;url-loader&apos;, query:&#123; limit:50000, name:&apos;assets/[name]-[hash:5].[ext]&apos; &#125;&#125; 然后打包一下 就会看见，我们的图片文件如果大于设置的limit：50000,50k时，会直接把图片loader进来，如果文件没有50k大师，怎会处理成base:64位的编码 3. 图片压缩 – image-webpack-loader首先先安装1npm install image-webpack-loader --save-dev 然后我们修改loader 为： 123456789101112&#123;//loader img test:/\.(png|jpg|gif|svg)$/, // loader:&apos;url-loader&apos;,//loader 可省略 // query:&#123; // limit:300000, // name:&apos;assets/[name]-[hash:5].[ext]&apos; // &#125; loaders:[ &apos;url-loader?limit=300000&amp;name=assets/[name]-[hash:5].[ext]&apos;, &apos;image-webpack-loader&apos; ] &#125; 上边还是遵守loader的顺序（从右到左），先是把图片压缩，压缩后的图片再交给url-loader 判断 是否大于limit值，大于直接交给file-loader 引入，如果在范围之内就把图片转成base：64位的编码]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack项目流程学习（一）]]></title>
    <url>%2F2017%2F04%2F10%2Fwebpack-1%2F</url>
    <content type="text"><![CDATA[前言 前端开发和其他开发工作的主要区别，首先是前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统，这个理想中的模块化系统是前端工程师多年来一直探索的难题。 什么是 WebpackWebpack 是一个模块打包器。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。 学习 Webpack本文只是本人webpack学习时所做的简单笔记，围绕这个视频所作，笔记是以项目的方式记录；仅供参考！ 项目开始 新建文件夹 1mkdir &lt;your name&gt; 进入文件夹 1cd &lt;your name&gt; 格式化 1npm init 下载安装 webpack 本地安装 1npm install webpack --save-dev 创建项目文件创建文件index.html 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;webpac demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;script type="text/javascript" src="bundle.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 里边添加bundle.js 的js 文件 创建 测试文件main.js 然后创建配置文件 webpack.config.js， 配置入口entry，输出output 12345678module.exports = &#123; context:__dirname,//当前目录 entry:'./src/script/main.js', output:&#123; path:'./dist/js', filename:'bundle.js' &#125;&#125; 然后在终端输入webpack就会在dist/js文件夹下生成bundle.js文件 配置文件的名字 建议为默认的webpack-config.js,方便执行（其他名称执行命令为webpack &lt;配置文件名称&gt;） 为了以后执行命令方便 可以在package.json中做配置 1234"scripts": &#123; "test": "echo \"Error: no test specified\" &amp;&amp; exit 1", "webpack": "webpack --config webpack.config.js --progress --display-modules --colors --display-reasons" &#125;, scripts中添加一项 &quot;webpack&quot;的配置 entry 可以为数组 1entry:[&apos;./src/script/main.js&apos;,&apos;./src/script/a.js&apos;], 最后打包的文件都会在bundle.js 中显示 entry 为对象时， output 的filename 可以用占位符 [name],[hash],[chunkhash]; 安装插件 1npm install html-webpack-plugin --save-dev 配置文件简历插件引用 1var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;); 添加插件在moudle.exports中添加 12345plugins:[ new htmlWebpackPlugin(&#123; telmplate:&apos;index.html&apos; &#125;)] 这样我们更改根目录的index.html文件执行 就会在dist/js下边生成个index.html文件 里边的js都自动引入进来了但是我们工作中 index.html 都是在根目录下的 所以要更改文件的生成路径 在 output下边 修改1234output:&#123; path:&apos;./dist&apos;, filename:&apos;js/[name]-[chunkhash].js&apos;&#125;, 这样 就会得到想要的结果 js的路径也只在js文件夹下 如果想要js 文件放在html的head 可以在plugin里边添加 1inject:&apos;head&apos; 我们可以设置一些参数 比如title，详见webpack 官网 的plugin 配置 也可以书写js ，如date:new Date() html里边书写插件 123&lt;title&gt;&lt;%=htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;&lt;p&gt;&lt;%=htmlWebpackPlugin.options.date %&gt;&lt;/p&gt; 插入js 1&lt;script type=&quot;text/javascript&quot; src=&quot;&lt;%= htmlWebpackPlugin.files.chunks.a.entry %&gt; &quot;&gt;&lt;/script&gt; html 中可以书写js 模板文件的方式遍历 查找完整的配置参数 文件 也可以到npm 官网上去查看插件的详细信息 （在npm 搜索框里边输入 插件名称 进行查看 ） 12345678910111213&lt;body&gt; &lt;!--js 模板文件的方式遍历 --&gt; &lt;%=htmlWebpackPlugin.options.date %&gt; &lt;!-- 直接运行js代码 --&gt; &lt;% for(var key in htmlWebpackPlugin.files) &#123;%&gt; &lt;%= key %&gt;:&lt;%=JSON.stringify(htmlWebpackPlugin.files[key]) %&gt; &lt;%&#125;%&gt; &lt;% for(var key in htmlWebpackPlugin.options) &#123;%&gt; &lt;%= key %&gt;:&lt;%=JSON.stringify(htmlWebpackPlugin.options[key]) %&gt; &lt;%&#125;%&gt;&lt;/body&gt; 打包后文件上线 ，使用output 新属性 publicPath,设置发布后的统一路径 plugin配置里边可以添加minify设置压缩的参数 12345minify:&#123; removeComments:true, collapseWhitespace:true &#125; 文件压缩 minify设置压缩的参数 详见 html-minifier 生成多个页面 entry 中添加 引入的 js文件 123456entry:&#123; main:'./src/script/main.js', a:'./src/script/a.js', b:'./src/script/b.js', c:'./src/script/c.js' &#125;, 与之对应的，在配置文件plugin 下添加 制定chunks 1234567891011121314151617181920212223plugins:[ new htmlWebpackPlugin(&#123; filename:'a.html', template:'index.html', inject:'body', title:'webpack is good a', chunks:['main','a'] &#125;), new htmlWebpackPlugin(&#123; filename:'b.html', template:'index.html', inject:'body', title:'webpack is good b', chunks:['b'] &#125;), new htmlWebpackPlugin(&#123; filename:'c.html', template:'index.html', inject:'body', title:'webpack is good c', chunks:['c'] &#125;) ] 也可以除了xx.js的文件，其余的都引用 可以在plugin下边修改chunks 为 1excludeChunks['b','c'] 表示生成文件中除了 b.js,c.js 其他的文件都生成并在HTML中导入 减少http请求 js 可以使用 js inline 到HTML中 找到不需要publicPath 的路径 123&lt;script type="text/javascript"&gt; &lt;%=htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length) %&gt;&lt;/script&gt; 取到里边的内容 修改上边代码 123&lt;script type="text/javascript"&gt; &lt;%=compilation.assets[htmlWebpackPlugin.files.chunks.main.entry.substr(htmlWebpackPlugin.files.publicPath.length)].source() %&gt; &lt;/script&gt; 这样 main.js里边的文件就会inline在 HTML中 如果 我们只让 main.js文件inline 其他 js 文件 引入 则需要在HTML文件中 循环一下 1234567&lt;% for(var k in htmlWebpackPlugin.files.chunks)&#123; %&gt; &lt;%if(k !=='main')&#123; %&gt; &lt;script type="text/javascript" src="&lt;%= htmlWebpackPlugin.files.chunks[k].entry %&gt;"&gt; &lt;/script&gt; &lt;% &#125;%&gt; &lt;%&#125;%&gt; 把插件 plugin 的 inject 改为&#39;body&#39;, 引入的文件就会显示在HTML的body 底部]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端图谱，前端工具大全]]></title>
    <url>%2F2017%2F03%2F01%2FWeb-Map%2F</url>
    <content type="text"><![CDATA[文章转自 VICHILY’S BLOG 核心 Core HTML5 W3C W3C 菜鸟教程 HTML5中文门户 CSS3 W3C CSS教程 W3C CSS3教程 菜鸟教程CSS教程 菜鸟教程CSS3教程 CSS参考手册 JS W3C 菜鸟教程 廖雪峰js教程 js标准参考教程-阮一峰 jQuery W3C 菜鸟教程 极客学院 廖雪峰 参考手册 参考手册 ES6 阮一峰ES6 极客学院 JavaScript标准参考阮一峰 插件 parallel.js: 前后端通用的一个并行库 zepto: 用于现代浏览器的兼容 jQuery 的库 totoro: 稳定的跨浏览器测试工具 TheaterJS: 一个用于模拟人输入状态的 JS 库 stellar.js: 前端用于实现异步滚动效果的库，现已不再维护 skrollr: 另一款实现一步滚动的开源库，使用人数众多，可实现各种狂拽酷炫掉渣天的前* 端效果，看真相 Framework7: 前端框架，是开发人员可以基于 web 技术构建 IOS7 程序 regulex: 用于生成 正则表达式 的可视化流程图 markdown-it: 新型 Markdown 解析器，快速，支持插件 multiline: 用于 Javascript 中的多行文本，类似于 Ruby 的 HERE Doc screenfull.js: 全屏插件，支持各大浏览器 lunr.js: 类似于 Solr, 但是用于浏览器上的全文搜索引擎，可以为 JSON 创建索引，离线也可以使用 jquery.hotkeys: jQuery 插件，用于绑定热键 breach_core: Javascript 编写的 Browser (浏览器) octocard: 用于生成 Github 信息卡片的库 github-cards: 用于生成 Github 信息卡片的库 money.js: 轻量级货币转换库，web 和 node 皆可用 accounting.js: 轻量级的数字、货币转换库 javascript-algorithms: Javascript 实现的各种算法集合 lazy.js: 类似于 underscore, 但是会延迟执行，某些场景下，性能会有很大的提升 seajs: 前端模块加载器，解决模块化、依赖等问题 jQuery-One-Page-Nav: 单页应用中一个用于处理导航栏的库 js.js: Javascript 实现的 javascript JIT jquery-ui: jQuery 团队开发的 UI 相关的前端库，功能强大 todomvc: 分别基于 AngularJS/EmberJS/Backbone等实现的 TODO List, 帮助开发者选择前端 MVC 库 localForage: Mozilla 出品，用于离线存储，基于IndexedDB, WebSQL 或者 localStorage, 提供一致的接口 EventEmitter: 浏览器版的 EventEmitter jquery.serializeJSON: jQuery 插件，用于将 form 表单序列化成 JSON 数据 knockout: 前端 MVVM 框架，用于开发富前端应用 mermaid: 可以根据文本生成流程图，类似于 Markdown 的语法 js-sequence-diagrams: 另一款可以根据文本生成流程图的库，类似于 Markdown 的语法 flow: 一个用来检测 Javascript 语法错误的库， Facebook 出品 zoomooz: jQuery 插件，用来处理浏览器缩放 fancyBox: 一个用于放大缩小图片、Web 内容或者多媒体元素的库，优雅大方 mithril.js: 轻量型前端 MVC 框架，部分使用场景下性能优于 Angular.js 和 React backbone: 强大的前端 MVC 库，鼻祖级前端库，最初为了配合 Rails 来模块化前端应用，兼容性良好 (兼容到 IE6)，插件丰富，性能良好 jquery.smartbanner: smartbanner 是从 IOS6 开始支持的一个新特性, 这个插件提供了对早期 IOS4/5 和 Android 的支持 jquery.scrollTo: 在页面上以一个元素为起始以动画的方式移动(ScrollTo)到另一个元素， 支持回退等 jScrollPane: 自定义的滚动条，让所有浏览器都显示一样的滚动条 onepage-scroll: 提供类似于 iPhone6 展示页类似的效果，适用于单页应用，兼容到 IE8 scrollMonitor: 前端插件用来监控元素的滚动事件(进入、退出等)，性能很好 ScrollMagic: 神奇的滚动交互效果插件，可以在滚动的过程中设置各种各样的动态效果 infinite-scroll: 滚动加载，滚动到最下到自动加载， Paul Irish 大神之作 animatable: 仅仅依靠 border-width 和 background-position 实现的各种动态效果，看真相 Fluidbox: 页面上内嵌图片的放大缩小效果，类似于 Medium 中的效果 jquery-validation: jQuery 的一个插件，用于校验 Form 表单 BigVideo.js: jQuery 的一个插件, 用于实现大背景(视频、图片)效果 emscripten: 一款基于 LLVM, 可以将 C/C++ 转换成 Javascript 的工具，使得 Javascript 可以近乎 Native 的速度 qrcode-generator: 各种语言的二维码生成工具 device.js: 一个可以检测设备类型的工具，可以让我们根据不同的设备来为其定制响应的 * Javascript 和 CSS jquery-qrcode: jQuery 插件，用来生成二维码 Wookmark-jQuery: jQuery 的一个插件，可以用来实现瀑布流的效果 isotope: 可以用来过滤、排列布局，实现美观的动态布局切换效果，Demo lazysizes: 功能强大的图片延迟加载工具，可以首先加载一个低质量的图片，然后再加载高质量的图片 progressbar.js: 简洁美观的进度条，扁平化 pigshell: 一个由 Javascript 实现的Shell, 将互联网当做一个大的文件系统, 通过 cd/ls/cat…..等命令, 可以访问 Facebook/Twitter/Google Drive 等网络服务 spectrum: Js实现的颜色选择器 (Colorpicker) jQuery.countdown: jQuery 倒计时插件 summernote: WYSIWYG 富文本编辑器 awesomplete: 非常轻型的一个自动补全 JS 库, 没有任何依赖, 配置简单, 美观 switchery: IOS 7 上 Switch 的 JS 实现, 支持 IE8 及以上浏览器 trix: Basecamp 公司出品的富文本编辑器，简洁小巧 sensor.js: 在智能移动设备浏览器上，通过HTML5的api使用移动设备的功能。定位、运动、倾斜等 hyhyhy: 用于创建 基于 HTML5 的 演示文稿 swipebox: jQuery 插件，用于处理移动端的触摸事件 FileAPI: 前端用户处理文件（拖放、多文件上传等） Sortable: 现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React，不依赖 jQuery Swiper: 用于实现浏览器上的滑动切换效果，支持硬件加速 matter-js: 2D 物理效果引擎，碰撞、弹跳等 jQTouch: 用于辅助创建手机端的 Web 应用，支持主题、Zepto.js 等 snabbt.js: 一个利用 Javascript 和 CSS transform 的 animation 库 c3: 基于 D3 的图表库 echarts: 企业级图表库，百度开发 parallax.js: 一个用于响应智能手机 orientation 的库 jQuery-Animate-Enhanced: jQuery 动画库的一个增强，用于现代浏览器 wysihtml: 富文本编辑器，适用于现代浏览器 slip: 一个通过滑动或者拖拽来操控列表的库 evil-icons: 一个矢量图库，提供 Ruby/Node 等支持 PhotoSwipe: JS 的一个图片展示库 focusable: 是页面上一个元素高亮的库，有图有真相 firefox.html: Firefox 在浏览器端的实现 —— HTML 版的 Firefox jquery-mobile: jQuery 团队开发的用于辅助手机端 web app 开发的库，基于 HTML5 mobile-angular-ui: 基于angularjs和bootstarp的web app开发框架 interact.js: 一个适用于现代浏览器的，用于处理 手势、拖放、缩放等的库 rebound-js: 实现部分物理效果，Facebook 出品 basket.js: 基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存 iscroll: 高性能的滚动(scroll)处理库，功能强大，支持各种事件，不依赖任何的库，且插件丰富, 大众点评的手机端列表滚动就是用这个库处理的 metrics-graphics: 基于 D3 的图表库，简洁、高效，Mozilla 出品 accessible-html5-video-player: Paypal 出品的 Video 播放器 loading: 几种 Loading 效果，基于 SVG flippant.js: 一款能够漂亮的网页元素翻转效果库，代码许久不更新，不过作为源码学习还是不错的 move.js: 基于 CSS3 的前端动画框架 scrollReveal.js: 使元素以非常酷帅的方式进入画布 (Viewpoint)，看 Demo Modernizr: 一个用来检测 HTML5 和 CSS3 支持情况的库 foundation: 另一款前端模版框架，类似于 Bootstrap Flat-UI: Bootstrap 的一款主题，简洁美观 iCheck: 一款漂亮的 Checkbox 插件 Swipe: 非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kb slick: 功能异常强大的一个图片滑动切换效果库 SocialButtons: 漂亮的社交按钮 sweetalert: 一个非常美观的用于替换浏览器默认 alert 的库 web-animations-js: Javascript 实现的 Web Animation API vivus: 可以动态描绘 SVG 的 JS 库, 支持多种动画 plyr: 轻量, 小巧, 美观的 HTML5 视频播放器 timesheet.js: 基于 HTML5 &amp; CSS3 时间表 slideout: 一个非常美观的侧滑菜单 hammerJs: 一个优秀的、轻量级的触屏设备手势库，文档 Textillate.js: jquery使用CSS3实现文字动画效果插件Textillate.js包管理工具 Package Managers NPM 菜鸟教程NPM 使用介绍 淘宝 NPM 镜像 npm 模块安装机制简介 npm包搜索地址 Bower Bower中文网 Bower：客户端库管理工具-阮一峰 Yarn yarn中文网 快速、可靠、安全的依赖管理 YARN 简介 编辑器 Text EditorsWebStorm 官网下载 前端网破解版下载 VScode 官网下载 vscode 插件精选 - 献给所有前端工程师 SublimeText 官网下载 前端网破解版插件版下载 SublimeCodeIntel: Sublime Text 的代码补全工具，支持多种语言 Emmet：一个用于提高开发效率的编辑器插件，前身是Zen coding SublimeLinter: 一个提供代码质量检测的插件 SublimeTmpl：快速新建指定的模版文件 Syntax-highlighting-for-Sass：sass代码高亮插件 MarkdownEditing: Sublime Text 强大的 Markdown 扩展, 提供快捷键, 主题等 ApplySyntax: 辅助检测语法插件 CTags: Sublime Text Ctags 支持插件, 需要安装 ctags sublime-react: React 代码高亮 Atom 官网下载 HBuilder 官网下载 JS框架 JS FrameworksBackbone Backbone.js API中文文档 AngularJs 中文官方文档 angularjs中文网 angularjs教程 Angular 基础入门 angular-masonry: Masonry 的 AngularJS 插件，用于瀑布流 angular-schema-form: 根据 JSON 生成响应的 Form 表单 restangular: Angular 中用来处理 RESTful API 的插件，可替代 $resource ng-cordova: Cordova 常用组件的 Angular 版本 angular-translate: Angular 的国际化 (I18n) ng-inspector: Chrome 插件，用于调试 Angular angularjs-style-guide: AngularJS 代码风格 ngReact: React 的 Angular 插件，可以在 Angular 中使用 React Components material: Google Material Design 效果的 Angular 实现 angular-local-storage: Angular 插件, 提供了对 localStorage 的友好支持, 并对不支持的浏览器使用 cookie 优雅降级 angular-filter: 一组有用的 Angular Filters bindonce: Angular 插件, 用于减少 Watcher 的数量, 提升性能 React 英文官方文档 中文官方文档 gitbooks手册 阮一峰react入门 阮一峰React Router入门 React Router 中文文档 react-redux 中文文档 阮一峰Redux 入门教程 react: React 框架源代码 react-native: Facebook 出品的使用 React 开发 IOS 原生应用的框架 react-hot-loader: 实时调整 React 组件效果 grunt-react: React 的 Grunt 组件, 用于将 JSX 编译成 JS touchstonejs: 基于 React 的手机应用前端框架 essential-react: 基于 React, ES6, React-Router的一个应用脚手架 react-router: React 路由解决方案 Vue vue官方 vuex官方 vue-router官方 UI框架 UI FrameworksBootstrap 最受欢迎的 HTML、CSS 和 JS 框架 Ionic 一款接近原生的Html5移动App开发框架 会html css js就可以开发app Foundation Foundation 中文网 迄今为止最好的响应式前端框架 FrozenUI 移动端服务的前端框架 materializecss 基于Material Design的主流前端响应式框架 mui 最接近原生APP体验的高性能前端框架 AntDesign 和react配合的UI框架 eleme 和vue配合的UI框架 JS预处理 JS PreprocessorsTypeScript TypeScript 入门教程 菜鸟教程 TypeScript中文网 TypeScript教程gitbook CoffeeScript CoffeeScript 中文 CoffeeScript 实用手册 极客学院 过程自动化 Process AutomationGrunt Grunt中文网 Gulp gulp.js 中文网 Gulp新手入门教程 gulp详细入门教程 前端构建工具gulpjs的使用介绍及技巧 Gulp开发教程 模板引擎 TemplatingHandlebars handlebarsjs官网 Handlebars中文文档 Handlebars.js 中文文档 Handlebars的使用方法文档整理 Haml haml官方文档 haml入门 Jade Jade 官方的英文文档 Jade的使用 带你学习Jade模板引擎视频 构建工具 Build ToolsRequireJS RequireJS 英文网 RequireJS 中文网 require.js的用法-阮一峰 seajs seajs文档 SeaJS从入门到原理 Browserify 官网 github Webpack Webpack 中文指南 webpack的实例 webpack的入门 一小时包教会 —— webpack 入门指南 CSS预处理器 CSS PreprocessorsSass sass入门 sass参考手册 SASS用法指南-阮一峰 Less less中文网 less快速入门 stylus stylus中文文档-张鑫旭 版本控制 Version ControlGit Git教程-廖雪峰 Svn 史上最简单的SVN使用教程和注意事项 SVN 教程 极客学院 SVN 教程 菜鸟教程 文章来源:VICHILY’S BLOG]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3的3D立体效果]]></title>
    <url>%2F2017%2F02%2F10%2Fcss3-3d%2F</url>
    <content type="text"><![CDATA[周末朋友叫我去看电影，我：“啥片，3D的不？”，朋友：“不是！”；我：“不是3D那就不去了，等以后在电脑上看吧，去电影院不就是去感受影片的3D的视觉效果么！”朋友：“……” 做网页也一样，现在2D已经不能满足我们的视觉需求，为了追求视觉冲突的真实感，我们往往会使用一些css3 3D效果的交互；最近我被淘宝造物节给刺激了，试着学着折腾css3的 3D transform效果。虽然现在还没有达到效果，但是还是有所收获。 建立立体感 首先我们要有一定的立体感： 通过这个图片应该清楚的了解到了x轴 y轴 z轴是什么概念了。 3D transform 就是沿着x轴 y轴 z轴 做变化； 3D transform中有下面这三个方法： rotateX( angle ) rotateY( angle ) rotateZ( angle ) rotateX旋转X轴，rotateY旋转Y轴，rotateZ旋转Z轴，括号里边都是变化的度数；3d无非就是通过X Y Z轴来进行操作 搭建3D搭建之前首先明白以下属性的意思：transform-style: preserve-3d; 3d空间perspective: 800px;它被成为视距或者景深.perspective-origin:50% 50%; 这就是你的眼睛位置 位置不同效果也就不用了 translateZ则可以帮你理解透视位置。transform-origin我们成为基点 在水平方向改变观看div的位置backface-visibility:hidden;为了切合实际，我们常常会这样设置，使后面元素不可见scale 缩放 rotate 旋转 translate移动 skew倾斜 通过这些来进行3d效果 一个小例子： HTML:123456789 &lt;div id="box"&gt; &lt;div class="bian zhi1"&gt; &lt;img src="01.jpg" alt=""&gt; &lt;/div&gt; &lt;div class="bian zhi2"&gt; &lt;img src="02.jpg" alt=""&gt; &lt;/div&gt;&lt;/div&gt; CSS:123456789101112131415161718192021222324#box&#123; width: 300px; height: 300px; margin: 0 auto; transform-style: preserve-3d; position: relative; transition: 2s; &#125; #box:hover&#123; transform:rotateY(180deg);&#125; #box .bian&#123; width: 300px; height: 300px; text-align: center; line-height: 300px; font-size: 100px; position: absolute;&#125; .zhi1&#123; background-color: red; transform:rotateY(180deg); &#125; .zhi2&#123; background-color: yellow; backface-visibility: hidden;/*设置后面的可视度为看不见 */&#125; 实例我们可以用css 3Dtransform制作个魔方首先先让六个面全部叠加在一起； 通过自己对3d空间的理解 和 x y z 轴的移动来拼接这个立方体；然后使用css3 动画 animation 改变rotate值，使其动起来 部分css3代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#box &#123; perspective: 800px; transform-style: preserve-3d; transition: 5s infinite; transform: rotateX(0deg) rotateY(0deg);&#125;.mofang_box &#123; width: 200px; height: 200px; margin: 300PX auto; position: relative; transform-style: preserve-3d; -webkit-animation: rotate 60s linear infinite; -o-animation: rotate 60s linear infinite; animation: rotate 60s linear infinite;&#125;@-webkit-keyframes rotate&#123; 0%&#123; transform: rotateX(0deg) rotateY(0deg); &#125; 100% &#123; transform: rotateX(3600deg) rotateY(3600deg); &#125;&#125;.mofang_box:hover &#123; transform: rotateX(3600deg) rotateY(3600deg);&#125;.mofang &#123; width: 200px; height: 200px; text-align: center; line-height: 200px; position: absolute;&#125;.left&#123; transform:rotateY(90deg)translateZ(-100px);&#125;.right &#123; transform: rotateY(90deg) translateZ(100px);&#125;.top &#123; transform: rotateX(90deg) translateZ(100px) rotateZ(360deg);&#125;.buttom &#123; transform: rotateX(90deg) translateZ(-100px) rotateZ(180deg);&#125;.hou &#123; transform: rotateX(0deg) translateZ(-100px) rotateZ(180deg);&#125;.qian &#123; transform: rotateX(0deg) translateZ(100px);&#125; 设置6个div分别表示left(左)、right(右)、top(上)、buttom(下)、hou(后)、qian(前)各六个面，然后给一定的transform形成一个立方体，再给整体添加个动画，让其自运动 查看完整代码 2.css3 3D轮播图（demo） 参考文章：一篇文章搞定css3 3d效果好吧，CSS3 3D transform变换，不过如此！图片来源于网络]]></content>
      <categories>
        <category>css3</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>3d</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shake--手机摇一摇]]></title>
    <url>%2F2017%2F01%2F17%2Fshake-mobile%2F</url>
    <content type="text"><![CDATA[马上过年了，发红包肯定是不能少的，为了增加趣味性，我们可以做一个摇一摇抢红包。 页面演示(用手机扫描下边二维码) 查看代码 操作流程 页面刚打开，是不能执行摇一摇，需要点击Shake按钮开启； 点击按钮后，会有一个摇一摇动画，提示可也摇； 摇一摇后执行函数，弹出奖品页面 HTML页面1234567891011121314151617&lt;div class="container"&gt; &lt;button&gt;Shake&lt;/button&gt; &lt;img class="yaoPic" src="images/ico-yao.png" alt=""&gt; &lt;div class="showPage"&gt; &lt;h2&gt;Congratulations &lt;br/&gt;to you on the award!&lt;/h2&gt; &lt;img class="qr" src="images/qr.png" alt=""&gt; &lt;span&gt;&lt;img src="images/close.svg" alt=""&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt;&lt;audio controls="controls" id="audio" autoplay="false" loop="false" style="display: none"&gt; &lt;source src="shake.mp3" type="audio/mp3" /&gt;&lt;/audio&gt;&lt;!--noHorizontal--&gt;&lt;section id="noHorizontal"&gt; &lt;div&gt;&lt;/div&gt; &lt;p&gt;请在竖屏模式下浏览&lt;/p&gt;&lt;/section&gt; button按钮为摇一摇的开关，如果不点击，摇一摇函数不会执行；yaoPic 点击按钮后 图片会有一个摇一摇的动画，提示现在可以开始摇一摇；showPage 是摇一摇后的回调函数：显示要到的内容； 库 引入代码库 shake.js: 1&lt;script src="shake.js"&gt;&lt;/script&gt; shake.js代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123(function(global, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; define(function() &#123; return factory(global, global.document); &#125;); &#125; else if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports = factory(global, global.document); &#125; else &#123; global.Shake = factory(global, global.document); &#125;&#125; (typeof window !== 'undefined' ? window : this, function (window, document) &#123; 'use strict'; function Shake(options) &#123; //feature detect this.hasDeviceMotion = 'ondevicemotion' in window; this.options = &#123; threshold: 15, //default velocity threshold for shake to register timeout: 1000 //default interval between events &#125;; if (typeof options === 'object') &#123; for (var i in options) &#123; if (options.hasOwnProperty(i)) &#123; this.options[i] = options[i]; &#125; &#125; &#125; //use date to prevent multiple shakes firing this.lastTime = new Date(); //accelerometer values this.lastX = null; this.lastY = null; this.lastZ = null; //create custom event if (typeof document.CustomEvent === 'function') &#123; this.event = new document.CustomEvent('shake', &#123; bubbles: true, cancelable: true &#125;); &#125; else if (typeof document.createEvent === 'function') &#123; this.event = document.createEvent('Event'); this.event.initEvent('shake', true, true); &#125; else &#123; return false; &#125; &#125; //reset timer values Shake.prototype.reset = function () &#123; this.lastTime = new Date(); this.lastX = null; this.lastY = null; this.lastZ = null; &#125;; //start listening for devicemotion Shake.prototype.start = function () &#123; this.reset(); if (this.hasDeviceMotion) &#123; window.addEventListener('devicemotion', this, false); &#125; &#125;; //stop listening for devicemotion Shake.prototype.stop = function () &#123; if (this.hasDeviceMotion) &#123; window.removeEventListener('devicemotion', this, false); &#125; this.reset(); &#125;; //calculates if shake did occur Shake.prototype.devicemotion = function (e) &#123; var current = e.accelerationIncludingGravity; var currentTime; var timeDifference; var deltaX = 0; var deltaY = 0; var deltaZ = 0; if ((this.lastX === null) &amp;&amp; (this.lastY === null) &amp;&amp; (this.lastZ === null)) &#123; this.lastX = current.x; this.lastY = current.y; this.lastZ = current.z; return; &#125; deltaX = Math.abs(this.lastX - current.x); deltaY = Math.abs(this.lastY - current.y); deltaZ = Math.abs(this.lastZ - current.z); if (((deltaX &gt; this.options.threshold) &amp;&amp; (deltaY &gt; this.options.threshold)) || ((deltaX &gt; this.options.threshold) &amp;&amp; (deltaZ &gt; this.options.threshold)) || ((deltaY &gt; this.options.threshold) &amp;&amp; (deltaZ &gt; this.options.threshold))) &#123; //calculate time in milliseconds since last shake registered currentTime = new Date(); timeDifference = currentTime.getTime() - this.lastTime.getTime(); if (timeDifference &gt; this.options.timeout) &#123; window.dispatchEvent(this.event); this.lastTime = new Date(); &#125; &#125; this.lastX = current.x; this.lastY = current.y; this.lastZ = current.z; &#125;; //event handler Shake.prototype.handleEvent = function (e) &#123; if (typeof (this[e.type]) === 'function') &#123; return this[e.type](e); &#125; &#125;; return Shake;&#125;)); 实现实现、设置参数如下123456789101112131415161718192021222324252627282930313233//create a new instance of shake.js.var myShakeEvent = new Shake(&#123; threshold: 15&#125;);// start listening to device motionbtn.addEventListener('touchend',function()&#123; yao.className = 'yaoPic yaoAni'; // start listening to device motion myShakeEvent.start();&#125;,false);// register a shake eventwindow.addEventListener('shake', shakeEventDidOccur, true);//shake event callbackfunction shakeEventDidOccur () &#123; //if phone support navigator.vibrate if (navigator.vibrate) &#123; //vibrate 1 second navigator.vibrate(1000); &#125; else if (navigator.webkitVibrate) &#123; navigator.webkitVibrate(1000); &#125; //put your own code here etc. audio.play(); audio.loop = false; setTimeout( function()&#123; showPage.className = 'showPage showAni'; &#125;,600); document.title = 'shaked! O_o' close.addEventListener('touchend',function()&#123; showPage.className = 'showPage'; &#125;,false);&#125; 代码中 myShakeEvent 里边设置摇动的幅度，数字越大，表示幅度越大，启动摇一摇函数； myShakeEvent.start();按钮点击后启动摇一摇函数； navigator.vibrate 检测手机是否支持振动，目前经测试大部分Android手机支持振动，ios不支持； 添加一个手机摇一摇声音，音乐执行一次就关闭 弹出页面内容可以使根据奖品内容不同随机展示]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[地图坐标与距离摸索]]></title>
    <url>%2F2016%2F12%2F27%2FMap-Location%2F</url>
    <content type="text"><![CDATA[昨天公司要求做一个关于地图的页面，要求根据自己的位置找到最近的客户店铺，然后测出相应的距离，最后点击显示到地图上。以下是我做后的总结： 引入地图API我选的是百度地图，需要在页面引入百度地图的jsAPI:1&lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=yourkey"&gt;&lt;/script&gt; 获取自己的定位以及目标的坐标首先获取自己的定位，需要征求用户的定位许可，然后根据手机/PC浏览器获取到自己的定位以及目标的坐标位置：123456789101112131415var map = new BMap.Map("map");geolocation.getCurrentPosition(function (r) &#123; if (this.getStatus() == BMAP_STATUS_SUCCESS) &#123; var mk = new BMap.Marker(r.point); map.addOverlay(mk); //map.panTo(r.point); //定位后地图直接跳转到定位的点 console.log(r.point.lng + ',' + r.point.lat); var point0 = new BMap.Point(r.point.lng, r.point.lat); //定位坐标 var pointA = new BMap.Point(103.9220890659,30.5741931982); // 创建点坐标A--双流顺城街店 var pointB = new BMap.Point(104.2947696856,30.5971282135); // 创建点坐标B--龙泉新城吾悦店 var pointC = new BMap.Point(103.9981777893,30.6769847095); // 创建点坐标B--金沙清江西路店 &#125;else &#123; alert('failed' + this.getStatus()); &#125;&#125;, &#123;enableHighAccuracy: true&#125;) 获取距离再比较远近获取每个创建坐标与定位坐标之间的的距离123(map.getDistance(point0, pointA)).toFixed(0);//toFixed(0) 取小数点后0位(map.getDistance(point0, pointB)).toFixed(0);(map.getDistance(point0, pointC)).toFixed(0); 把这三个数存到数组arr中 遍历找到最小值123456789// 返回数组最大最小值function getMaximin(arr, maximin) &#123; if(maximin == "max")&#123; return Math.max.apply(Math, arr); &#125;else if (maximin == "min") &#123; return Math.min.apply(Math, arr); &#125;&#125;var meter = getMaximin(arr, "min");//获取到最小的值 显示最小值在页面上如果值大于一千米，换算单位为千米12345678if (meter == arr[i]) &#123; if (meter &gt;= 1000) &#123; var Mt = (meter / 1000).toFixed(1); m.innerHTML = '&lt;span&gt;您距离店铺只剩下' + Mt + '千米&lt;/span&gt;'; &#125; else &#123; m.innerHTML = '&lt;span&gt;您距离店铺只剩下' + meter + '米&lt;/span&gt;'; &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js实现淡入淡出效果]]></title>
    <url>%2F2016%2F12%2F19%2Fjs-fadeIn-fadeOut%2F</url>
    <content type="text"><![CDATA[淡出淡入效果，在日常生活中经常用到，使用jQuery的fadeIn/fadeOut很容易实现，但是页面需要引入jq库，所以就自己封装个库，可以直接使用。兼容IE7以上 （IE的透明度设置为0~100）。 参数说明：fadeIn()与fadeOut()均有三个参数，第一个为事件（必填）；第二个是淡出淡入效果速度，正整数，可选参数；第三个时指定淡出淡入到的透明度（类似于jQuery中的fadeTo()），0~100的正整数，参数为可选。 核心代码及演示： html代码：12345678910111213141516171819202122232425262728&lt;div id="demo"&gt; &lt;div class="box"&gt; &lt;h2&gt;&lt;input type="button" value="点击淡入" /&gt;&lt;/h2&gt; &lt;div id="fadeIn" style="display:none"&gt; &lt;p&gt;相信你还在这里&lt;/p&gt; &lt;p&gt;从不曾离去&lt;/p&gt; &lt;p&gt;我的爱像天使守护你，&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;h2&gt;&lt;input type="button" value="点击淡出" /&gt;&lt;/h2&gt; &lt;div id="fadeOut"&gt; &lt;p&gt;若生命只到这里&lt;/p&gt; &lt;p&gt;从此没有我&lt;/p&gt; &lt;p&gt;我会找个天使替我去爱你&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="box"&gt; &lt;h2&gt;&lt;input type="button" value="点击淡出至指定透明度" /&gt;&lt;/h2&gt; &lt;div id="fadeTo"&gt; &lt;p&gt;相信你还在这里&lt;/p&gt; &lt;p&gt;从不曾离去&lt;/p&gt; &lt;p&gt;我的爱像天使守护你，&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; javascript 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374window.onload = function() &#123; //底层共用 var iBase = &#123; Id: function(name) &#123; return document.getElementById(name); &#125;, //设置元素透明度,透明度值按IE规则计,即0~100 SetOpacity: function(ev, v) &#123; ev.filters ? ev.style.filter = 'alpha(opacity=' + v + ')' : ev.style.opacity = v / 100; &#125; &#125; //淡入效果(含淡入到指定透明度) function fadeIn(elem, speed, opacity) &#123; /* * 参数说明 * elem==&gt;需要淡入的元素 * speed==&gt;淡入速度,正整数(可选) * opacity==&gt;淡入到指定的透明度,0~100(可选) */ speed = speed || 20; opacity = opacity || 100; //显示元素,并将元素值为0透明度(不可见) elem.style.display = 'block'; iBase.SetOpacity(elem, 0); //初始化透明度变化值为0 var val = 0; //循环将透明值以10递增,即淡入效果 (function() &#123; iBase.SetOpacity(elem, val); val += 10; if (val &lt;= opacity) &#123; setTimeout(arguments.callee, speed) &#125; &#125;)(); &#125; //淡出效果(含淡出到指定透明度) function fadeOut(elem, speed, opacity) &#123; /* * 参数说明 * elem==&gt;需要淡出的元素 * speed==&gt;淡出速度,正整数(可选) * opacity==&gt;淡出到指定的透明度,0~100(可选) */ speed = speed || 20; opacity = opacity || 0; //初始化透明度变化值为0 var val = 100; //循环将透明值以10递减,即淡出效果 (function() &#123; iBase.SetOpacity(elem, val); val -= 10; if (val &gt;= opacity) &#123; setTimeout(arguments.callee, speed); &#125; else if (val &lt; 0) &#123; //元素透明度为0后隐藏元素 elem.style.display = 'none'; &#125; &#125;)(); &#125; var btns = iBase.Id('demo').getElementsByTagName('input'); btns[0].onclick = function() &#123; fadeIn(iBase.Id('fadeIn')); &#125; btns[1].onclick = function() &#123; fadeOut(iBase.Id('fadeOut'), 40); &#125; btns[2].onclick = function() &#123; fadeOut(iBase.Id('fadeTo'), 20, 10); &#125; &#125; css代码： 1234#demo div.box &#123;float:left;width:31%;margin:0 1%&#125; #demo div.box h2&#123;margin-bottom:10px&#125; #demo div.box h2 input&#123;padding:5px 8px;font-size:14px;font-weight:bolder&#125; #demo div.box div&#123;text-indent:10px; line-height:22px;border:2px solid #555;padding:0.5em;overflow:hidden&#125; 演示地址 本文修改与来源：http://mrthink.net/js-fadein-fadeout-fadeto/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS实现多行文本溢出显示省略号]]></title>
    <url>%2F2016%2F12%2F08%2Fcss-overflow%2F</url>
    <content type="text"><![CDATA[单行文本溢出显示省略号单行文本溢出隐藏显示出省略号，前提是要先定文本的宽度实现方法123456789.text1&#123; display: block; width:100px; font-size:14px; line-height:1.5; overflow: hidden;/*溢出隐藏*/ white-space: nowrap;/*禁止换行*/ text-overflow: ellipsis;/*超出文字以省略号显示*/&#125; 显示效果 多行文本溢出显示省略号 实现方法1234567.text2 &#123; width:100px; display: -webkit-box;/*课伸缩盒子、弹性盒子*/ -webkit-box-orient: vertical;/*从上往下垂直排列子元素*/ -webkit-line-clamp:3;/*限制在一块元素显示的文本的行数（超出三行显示省略号）*/ overflow: hidden;&#125; 显示效果因使用了WebKit的CSS扩展属性，所以该方法只适用于WebKit浏览器及移动端 兼容写法:（通过定为实现）实现方法123456789101112131415161718.text3 &#123; width:100px;/*自己定义高度*/ position:relative; line-height:20px;/*行高*/ max-height:80px;/*这里是行高的几倍就表示显示几行文本*/ overflow:hidden;&#125;.text3::after &#123; content:'...'; position:absolute; bottom:0; right:0; padding-left:40px; background:-webkit-linear-gradient(left,transparent,#fff 55%); background:-o-linear-gradient(right,transparent,#fff 55%); background:-moz-linear-gradient(right,transparent,#fff 55%); background:linear-gradient(to right,transparent,#fff 55%);&#125; 显示效果]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中定义对象的几种方式]]></title>
    <url>%2F2016%2F11%2F25%2Fjavascript-oop%2F</url>
    <content type="text"><![CDATA[JavaScript中没有类的概念，只有对象。在JavaScript中定义对象可以采用以下几种方式：1.基于已有对象扩充其属性和方法2.工厂方式3.构造函数方式4.原型(“prototype”)方式5.动态原型方式 基于已有对象扩充其属性和方法123456789101112 var object = new Object(); object.name = "zhangsan"; object.sayName = function(name)&#123; this.name = name; alert(this.name); &#125; object.sayName("lisi");&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; update hexo` 这种方式的弊端：这种对象的可复用性不强，如果需要使用多个对象，还需要重新扩展其属性和方法。 工厂方式12345678910111213141516function createObject()&#123; var object = new Object(); object.username = "zhangsan"; object.password = "123"; object.get = function()&#123; alert(this.username + ", " + this.password); &#125; return object;&#125;var object1 = createObject();var object2 = createObject();object1.get();` 改进一：采用带参数的构造方法： 1234567891011121314151617function createObject(username, password)&#123; var object = new Object(); object.username = username; object.password = password; object.get = function()&#123; alert(this.username + ", " + this.password); &#125; return object;&#125;var object1 = createObject("zhangsan", "123");object1.get();` 改进二：让多个对象共享函数对象这样，不用每个对象都生成一个函数对象。 12345678910111213141516171819function get()&#123; alert(this.username + ", " + this.password);&#125;//函数对象只有一份function createObject(username, password)&#123; var object = new Object(); object.username = username; object.password = password; object.get = get; //每一个对象的函数对象都指向同一个函数对象return object;&#125;var object = createObject("zhangsan", "123");var object2 = createObject("lisi", "456");object.get();object2.get(); 优点：让一个函数对象被多个对象所共享，而不是每一个对象拥有一个函数对象。缺点：对象和它的方法定义分开了，可能会造成误解和误用。 构造函数方式构造函数的定义方法其实和普通的自定义函数相同。 123456789101112function Person()&#123; //在执行第一行代码前，js引擎会为我们生成一个对象this.username = "zhangsan"; this.password = "123"; this.getInfo = function()&#123; alert(this.username + ", " + this.password); &#125; //此处有一个隐藏的return语句，用于将之前生成的对象返回//只有在后面用new的情况下，才会出现注释所述的这两点情况&#125;//生成对象var person = new Person();//用了newperson.getInfo(); 改进版：加上参数： 123456789101112function Person(username, password)&#123; this.username = username; this.password = password; this.getInfo = function()&#123; alert(this.username + ", " + this.password); &#125;&#125;var person = new Person("zhangsan", "123");person.getInfo(); 原型(“prototype”)方式例子：12345678910111213141516function Person()&#123;&#125;Person.prototype.username = "zhangsan";Person.prototype.password = "123";Person.prototype.getInfo = function()&#123; alert(this.username + ", " + this.password);&#125;var person = new Person();var person2 = new Person();person.username = "lisi";person.getInfo();person2.getInfo(); 使用原型存在的缺点： 1.不能传参数； 2.有可能会导致程序错误。 如果使用原型方式来定义对象，那么生成的所有对象会共享原型中的属性，这样一个对象改变了该属性也会反映到其他对象当中。单纯使用原型方式定义对象无法在构造函数中为属性赋初值，只能在对象生成后再去改变属性值。 比如，username改为数组后： 123456789101112131415161718function Person()&#123;&#125;Person.prototype.username = new Array();Person.prototype.password = "123";Person.prototype.getInfo = function()&#123; alert(this.username + ", " + this.password);&#125;var person = new Person();var person2 = new Person();person.username.push("zhangsan");person.username.push("lisi");person.password = "456";person.getInfo(); //输出：zhangsan,lisi, 456person2.getInfo(); //输出：zhangsan,lisi, 123//虽然没有对person2对象进行修改，但是它的name和person是一样的，即为zhangsan,lisi 这是因为使用原型方式，person和person2指向的是同一个原型，即对应了同样的属性对象。对于引用类型(比如数组)，两个对象指向了同一个引用，所以对一个所做的更改会影响另一个。而对于字符串(字面常量值)，重新赋值之后就指向了另一个引用，所以二者的修改互不影响。 对原型方式的改进： 使用原型+构造函数方式来定义对象，对象之间的属性互不干扰，各个对象间共享同一个方法。12345678910111213141516171819//使用原型+构造函数方式来定义对象function Person()&#123; this.username = new Array(); this.password = "123";&#125;Person.prototype.getInfo = function()&#123; alert(this.username + ", " + this.password);&#125;var p = new Person();var p2 = new Person();p.username.push("zhangsan");p2.username.push("lisi");p.getInfo();p2.getInfo(); 动态原型方式在构造函数中通过标志量让所有对象共享一个方法，而每个对象拥有自己的属性。 1234567891011121314151617181920212223function Person()&#123; this.username = "zhangsan"; this.password = "123"; if(typeof Person.flag == "undefined")&#123; //此块代码应该只在第一次调用的时候执行 alert("invoked"); Person.prototype.getInfo = function()&#123; //这个方法定义在原型中，会被每一个对象所共同拥有 alert(this.username + ", " + this.password); &#125; Person.flag = true;//第一次定义完之后，之后的对象就不需要再进来这块代码了 &#125;&#125;var p = new Person();var p2 = new Person();p.getInfo();p2.getInfo(); 文章来自网络，如有侵权请联系进行删除，谢谢]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的 this 详解]]></title>
    <url>%2F2016%2F11%2F25%2Fjavascript-this%2F</url>
    <content type="text"><![CDATA[关于 js 中的 this 文章的一个总结归纳 在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。 全局执行 首先，我们在全局环境中看看它的 this 是什么： 浏览器： 123console.log(this);// Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125; node： 123console.log(this); // global 可以看到打印出了 global 对象； 总结 ：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。 函数中执行 纯粹的函数调用 这是最普通的函数使用方法了：1234567function test() &#123; console.log(this);&#125;; test(); // Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125; 我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象； 严格模式 ‘use strict’; 如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为：12345678'use strict';function test() &#123; console.log(this);&#125;; test(); // undefined 当然，把它放在一个立即执行函数中会更好，避免了污染全局：1234567(function ()&#123; "use strict"; console.log(this);&#125;)(); // undefined` 作为对象的方法调用 当一个函数被当作一个对象的方法调用的时候：12345678910var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this.name); &#125;&#125; obj.foo(); // 'qiutc' 这时候，this 指向当前的这个对象； 当然，我们还可以这么做：1234567891011function test() &#123; console.log(this.name);&#125;var obj = &#123; name: 'qiutc', foo: test&#125; obj.foo(); // 'qiutc' 同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。 如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：1234567891011var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;&#125; var test = obj.foo;test(); // Window 可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。 一些坑 我们经常在回调函数里面会遇到一些坑：123456789101112var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;, foo2: function() &#123; console.log(this); setTimeout(this.foo, 1000); &#125;&#125; obj.foo2(); 执行这段代码我们会发现两次打印出来的 this 是不一样的： 第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑； 但是在 setTimeout 中执行的 this.foo ，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑； 其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。 这个问题是很多异步回调函数中普遍会碰到的； 解决 为了解决这个问题，我们可以利用 闭包 的特性来处理：12345678910111213141516var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;, foo2: function() &#123; console.log(this); var _this = this; setTimeout(function() &#123; console.log(this); // Window console.log(_this); // Object &#123;name: "qiutc"&#125; &#125;, 1000); &#125;&#125; obj.foo2(); 可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用_this，就可以指向当前的这个对象了； setTimeout 的另一个坑 之前啊说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同：123456789'use strict'; function foo() &#123; console.log(this);&#125; setTimeout(foo, 1); // window 按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？ 并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()； 当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);； http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code 作为一个构造函数使用 在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字： 12345678function Person(name) &#123; this.name = name; console.log(this);&#125; var p = new Person('qiutc'); // Person &#123;name: "qiutc"&#125; 我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象； 当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局：12345678function Person(name) &#123; this.name = name; console.log(this);&#125; var p = Person('qiutc'); // Window 其区别在于，如何调用函数（new）。 箭头函数 在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了： 1234567891011121314var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;, foo2: function() &#123; console.log(this); setTimeout(() =&gt; &#123; console.log(this); // Object &#123;name: "qiutc"&#125; &#125;, 1000); &#125;&#125; obj.foo2(); 可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 根据例子我们理解一下这句话： 在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj；，简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。 call, apply, bind 在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向： call 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数； apply 1fun.apply(thisArg[, [arg1, arg2, ...]]) 它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）； bind 1var foo = fun.bind(thisArg[, arg1[, arg2[, ...]]]); 它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数； 这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例； 为一个普通函数指定 this1234567891011var obj = &#123; name: 'qiutc'&#125;; function foo() &#123; console.log(this);&#125; foo.call(obj); // Object &#123;name: "qiutc"&#125; 可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功； 为对象中的方法指定一个 this 1234567891011121314var obj = &#123; name: 'qiutc', foo: function () &#123; console.log(this); &#125;&#125; var obj2 = &#123; name: 'tcqiu222222'&#125;; obj.foo.call(obj2); // Object &#123;name: "tcqiu222222"&#125; 可以看到，执行函数的时候这里的 this 指向了 obj2，成功； 为构造函数指定 this123456789101112function Person(name) &#123; this.name = name; console.log(this);&#125; var obj = &#123; name: 'qiutc2222222'&#125;; var p = new Person.call(obj, 'qiutc'); // Uncaught TypeError: Person.call is not a constructor(…) 这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数； 换成 bind 试试： 123456789101112131415161718function Person(name) &#123; this.name = name; console.log(this);&#125; var obj = &#123; name: 'qiutc2222222'&#125;; var Person2 = Person.bind(obj); var p = new Person2('qiutc'); // Person &#123;name: "qiutc"&#125; console.log(obj); // Object &#123;name: "qiutc2222222"&#125; 打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效； 因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效； 当然 bind 不仅可以指定this ，还能传入参数，我们来试试这个操作： 1234567891011121314function Person(name) &#123; this.name = name; console.log(this);&#125; var obj = &#123; name: 'qiutc2222222'&#125;; var Person2 = Person.bind(obj, 'qiutc111111'); var p = new Person2('qiutc'); // Person &#123;name: "qiutc111111"&#125; 可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了； 为箭头函数指定 this 我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢：123456789101112131415161718var afoo = (a) =&gt; &#123; console.log(a); console.log(this);&#125; afoo(1); // 1// Window var obj = &#123; name: 'qiutc'&#125;; afoo.call(obj, 2); // 2// Window 可以看到，这里的call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this 。 只要记住箭头函数大法好，不变的 this。 文章来源qiutc.me，如有侵权请联系进行删除，谢谢]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入javascript——构造函数和原型对象]]></title>
    <url>%2F2016%2F11%2F18%2Fjavascript-Object%2F</url>
    <content type="text"><![CDATA[常用的几种对象创建模式 使用new关键字创建 最基础的对象创建方式，无非就是和其他多数语言一样说的一样：没对象，你new一个呀！123456var gf = new Object();gf.name = "zhangSan";gf.bar = "c++";gf.sayWhat = function() &#123; console.log(this.name + "said:love you forever");&#125; 使用字面量创建 这样似乎妥妥的了，但是宅寂的geek们岂能喜欢如此复杂和low土的定义变量的方式，作为一门脚本语言那应该有和其他兄弟们一样的范儿，于是出现了对象字面量的定义方式： 1234567var gf = &#123; name : "zhangSan", bar : "c++", sayWhat : function() &#123; console.log(this.name + "said:love you forever"); &#125;&#125; 工厂模式 实际上这是我们在实际中最常用的对象定义方式，但是我要有好多拥有相似属性的对象（想想都让人激动。。。）怎么办呢？那要是一个个的定义，就会产生 大量的代码，何不建个工厂，批量的生产出我们的对象呢，于是，javascript世界中第一个充气娃。。。不，“工厂模式”诞生了！ 1234567891011function createGf(name, bar) &#123; var o = new Object(); o.name = name; o.bar = bar; o.sayWhat = function() &#123; alert(this.name + "said:love you forever"); &#125; return o;&#125;var gf1 = createGf("bingbing","d");var gf2 = createGf("mimi","a"); 构造函数 工厂模式解决了多个相似对象的创建问题，但是问题又来了，这些对象都是Object整出来的，怎么区分它们的对象具体类型呢？这时候我们就需要切换到另一种模式了，构造函数模式： 12345678910function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = function()&#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf("vivian","f");var gf2 = new Gf("vivian2","f");` 这里我们使用一个大写字母开头的构造函数替代了上例中的createGf，注意按照约定构造函数的首字母要大写。在这里我们创建一个新对象，然后将构造函数的作用域赋给新对象，调用构造函数中的方法。 上面的方式似乎没什么不妥，但是我们可以发现，两个实例中调用的构造函数中的sayWhat方法不是同一个Function实例：1console.log(gf1.sayWhat == gf2.sayWhat); //false 调用同一个方法，却声明了不同的实例，实在浪费资源。我们可以优化一下将sayWhat函数放到构造函数外面声明：12345678function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = sayWhat&#125;function sayWhat()&#123; alert(this.name + "said:love you forever");&#125; 这样解决了，多个实例多次定义同一个方法实例的问题，但是新问题又来了，我们定义的sayWhat是一个全局作用域的方法，但这个方法其实是没法直接调用的，这就有点矛盾了。如何更优雅的定义一个具备一定封装性的对象呢？我们来看一下javascript原型对象模式。 原型对象模式 理解原型对象 当我们创建一个函数时，该函数就会具备一个prototype属性，这个属性指向通过构造函数创建的那个函数的原型对象。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象。 在原型模式中，不必再构造函数中定义实例属性，可以将属性信息直接赋予原型对象：12345678910function Gf()&#123; Gf.prototype.name = "vivian"; Gf.prototype.bar = "c++"; Gf.prototype.sayWhat = function()&#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf();gf1.sayWhat();var gf2 = new Gf(); 和构造函数不同的是这里新对象的属性和方法是所有实例都可以共享的，换句话说gf1和gf2访问的是同一份属性和方法。原型对象中除了我们赋予的属性外，还有一些内置的属性，所有原型对象都具备一个constructor属性，这个属性是一个指向包含prototype属性函数的一个指针（敢不敢再绕点！）。通过一幅图我们来清楚的理一下这个绕口的流程： 所有的对象都有一个原型对象（prototype），原型对象中有一个constructor属性指向包含prototype属性的函数，Gf的实例gf1和gf2都包含一个内部属性指向原型对象（在firefox浏览器中表现为私有属性proto），当我们访问一个对象中的属性时，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象。 使用原型对象 在前面的示例中，我们注意到在为原型对象添加属性时，需要每个都增加Gf.prototype，这个工作很重复，在上面对象的创建模式中，我们知道可以通过字面量的形式创建一个对象，这里我们也可以改进一下： 12345678function Gf()&#123;&#125;Gf.prototype = &#123; name : "vivian", bar : "c++", sayWhat : function()&#123; alert(this.name + "said:love you forever"); &#125;&#125; 这里有一个地方需要特别注意下，constructor属性不再指向对象Gf，因为每定义一个函数，就会同时为其创建一个prototype对象，这个对象也会自动获取一个新的constructor属性，这个地方我们使用Gf.prototype本质上覆写了原有的prototype对象，因此constructor也变成了新对象的constructor属性，不再指向Gf，而是Object:123var gf1 = new Gf();console.log(gf1.constructor == Gf);//falseconsole.log(gf1.constructor == Object)//true 一般情况下，这个微妙的改变是不会对我们造成影响的，但如果你对constructor有特殊的需求，我们也可以显式的指定下Gf.prototype的constructor属性：12345678910Gf.prototype = &#123; constructor : Gf, name : "vivian", bar : "c++", sayWhat : function() &#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf();console.log(gf1.constructor == Gf);//true 通过对原型对象模式的初步了解，我们发现所有的实例对象都共享相同的属性，这是原型模式的基本特点，但往往对于开发者来说这是把“双刃剑”，在实际开发中，我们希望的实例应该是具备自己的属性，这也是在实际开发中很少有人单独使用原型模式的主要原因。 构造函数和原型组合模式 在实际开发中，我们可以使用构造函数来定义对象的属性，使用原型来定义共享的属性和方法，这样我们就可以传递不同的参数来创建出不同的对象，同时又拥有了共享的方法和属性。 123456789101112function Gf(name,bar)&#123; this.name = name; this.bar = bar;&#125;Gf.prototype = &#123; constructor : Gf, sayWhat : function() &#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf("vivian", "f");var gf2 = new Gf("vivian1", "c"); 在这个例子中，我们再构造函数中定义了对象各自的属性值，在原型对象中定义了constructor属性和sayWhat函数，这样gf1和gf2属性之 间就不会产生影响了。这种模式也是实际开发中最常用的对象定义方式，包括很多js库（bootstrap等）默认的采用的模式。 *文章来自网络，如有侵权请联系进行删除，谢谢]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周末随拍（2016.11.13）]]></title>
    <url>%2F2016%2F11%2F16%2Fthe-Accompanying-photograph%2F</url>
    <content type="text"><![CDATA[兴庆公园 兴庆公园 兴庆公园 兴庆公园 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔 小寨 #拍摄来自魅蓝E#]]></content>
      <categories>
        <category>个人随写</category>
      </categories>
      <tags>
        <tag>Photo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 上传本地文件到github]]></title>
    <url>%2F2016%2F11%2F12%2Fupload-git-for-github%2F</url>
    <content type="text"><![CDATA[Git 上传本地文件到github 1 git config –global user.name “Your Real Name” 2 git config –global user.email you@email.address 1234567git initgit add .git commit -m 'Test'git remote add origin git@github.com:XXX/XXX.git 3 git push -u origin master 一些可能遇到的问题解决： 如果输入$ git remote add origingit@github.com:djqiang（github帐号名）/gitdemo（项目名）.git提示出错信息：fatal: remote origin already exists. 解决办法如下： 1、先输入$ git remote rm origin 2、再输入$ git remote add origin git@github.com:djqiang/gitdemo.git 就不会报错了！ 3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’.我们需要修改gitconfig文件的内容 4、找到你的github的安装路径，我的是 1C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc 5、找到一个名为gitconfig的文件，打开它把里面的[remote &quot;origin&quot;]那一行删掉就好了！如果输入$ ssh -T git@github.com 出现错误提示：Permission denied(publickey).因为新生成的key不能加入ssh就会导致连接不上github。 解决办法如下： 1、先输入$ ssh-agent，再输入$ ssh-add ~/.ssh/id_key，这样就可以了。 2、如果还是不行的话，输入ssh-add ~/.ssh/id_key 命令后出现报错Could not open a connection to your authentication agent.解决方法是key用GitGui的ssh工具生成，这样生成的时候key就直接保存在ssh中了，不需要再ssh-add命令加入了，其它的user，token等配置都用命令行来做。 3、最好检查一下在你复制id_rsa.pub文件的内容时有没有产生多余的空格或空行，有些编辑器会帮你添加这些的。 如果输入$ git push origin master 提示出错信息：error:failed to push som refs to ……. 解决办法如下： 1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来 2、再输入$ git push origin master 3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository. 4、则需要重新输入$ git remote add origingit@github.com:djqiang/gitdemo.git 使用git在本地创建一个项目的过程12345678$ makdir ~/hello-world //创建一个项目hello-world$ cd ~/hello-world //打开这个项目$ git init //初始化$ touch README$ git add README //更新README文件$ git commit -m ‘first commit’ //提交更新，并注释信息“first commit”$ git remote add origin git@github.com:defnngj/hello-world.git //连接远程github项目$ git push -u origin master //将本地项目更新到github项目上去 我的github 同步测试： 1234567891011echo "# text" &gt;&gt; README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin https://github.com/Littlombie/text.gitgit push -u origin master…or push an existing repository from the command linegit remote add origin https://github.com/Littlombie/text.gitgit push -u origin master]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css3导航动画切换]]></title>
    <url>%2F2016%2F11%2F09%2FRotate-the-navigation%2F</url>
    <content type="text"><![CDATA[我们浏览有些手机网站时，有时会发现页面的导航打开动画很有意思，类似下图这种： 现在我们用html input表单以及css3实现这个功能，原理如下： html为用input 与label表单，label下边三个div表示导航的三条横线； 当点击label时，input会选中,与之对应的label下边三个div执行动画,其中第二个div让宽度为0，位置发生变化，第一个与第三个div执行旋转动画，形成×； 再次点击取消选中时，利用input的属性，恢复到选中之前的状态。 html代码如下： 12345678&lt;div class="nav_bar"&gt; &lt;input type="checkbox" id="nemu_button"&gt; &lt;label for="nemu_button"&gt; &lt;div class="line_top transition"&gt;&lt;/div&gt; &lt;div class="line_meddle transition"&gt;&lt;/div&gt; &lt;div class="line_bottom transition"&gt;&lt;/div&gt; &lt;/label&gt;&lt;/div&gt; css代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*过渡动画transition*/.transition &#123; -webkit-transition: all .25s ease-in-out; -moz-transition: all .25s ease-in-out; -ms-transition: all .25s ease-in-out; -o-transition: all .25s ease-in-out; transition: all .25s ease-in-out;&#125;#nemu_button &#123; position: absolute; left: 9999px;&#125;label &#123; position: absolute; right:50px; cursor:pointer;&#125;label&gt;div &#123; width: 30px; height: 2px; margin-bottom: 8px; background: #fff;&#125;/*input选中是 label下边的三条横线的过渡动画*/input:checked + label .line_top &#123; margin-top: 15px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);&#125;input:checked + label .line_meddle &#123; width: 0; margin-top: -15px; margin-left: 15px;&#125;input:checked + label .line_bottom &#123; margin-top: -5px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg);&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字化Loading]]></title>
    <url>%2F2016%2F11%2F07%2FLoading-Page%2F</url>
    <content type="text"><![CDATA[js页面从0~100%的loading； javascript代码： 12345678910111213141516171819function setSB(v, el) &#123; //判断页面是否加载完成 if (document.readyState == "complete") &#123; valueEl = el.children[0]; valueEl.innerText = v + "%";//显示百分比 &#125; &#125; function fakeProgress(v, el) &#123; if (v &gt; 100)&#123;//加载完成 document.querySelector('#text').innerHTML="加载完成"; setTimeout(function()&#123; document.querySelector('#sb').style.display="none"; &#125;,200); &#125; else &#123; setSB(v, el); window.setTimeout("fakeProgress(" + (++v) + ", document.all['" + el.id + "'])", 20); &#125; &#125; html代码： 123456789&lt;body onload="fakeProgress(0, sb)"&gt; &lt;center&gt; &lt;p id="text"&gt;正在载入中，请稍侯……&lt;/p&gt; &lt;span id='sb' style="width: 302px"&gt; &lt;div&gt;&lt;/div&gt; &lt;div style="font-size: 9pt; width: 100%; text-align: center"&gt;&lt;/div&gt; &lt;/span&gt; &lt;/center&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js轮播图(适用于PC)]]></title>
    <url>%2F2016%2F11%2F03%2F20161103js-Slider%2F</url>
    <content type="text"><![CDATA[实现自动左右轮播 鼠标移入停止轮播，鼠标移开继续轮播 prev next点击左右切换 点击下边导航可以跳转到相应的页 首先引入自己封装的简单的js运动库 move.js1&lt;script src="move.js"&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132function getStyle(obj, name) &#123; if (obj.currentStyle) &#123; return obj.currentStyle[name]; &#125; else &#123; return getComputedStyle(obj, false)[name]; &#125; &#125; function startMove(obj, attr, iTarget) &#123; clearInterval(obj.timer); obj.timer = setInterval(function() &#123; var cur = 0; if (attr == 'opacity') &#123; cur = parseFloat(getStyle(obj, attr)) * 100; &#125; else &#123; cur = parseInt(getStyle(obj, attr)); &#125; var speed = parseInt(iTarget - cur) / 6; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (cur == iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if (attr == 'opacity') &#123; obj.style.filter = 'alpha(opacity:' + (cur + speed) + ')'; obj.style.opacity = (cur + speed) / 100; &#125; else &#123; obj.style[attr] = cur + speed + 'px'; &#125; &#125; &#125;, 30); &#125; javascript代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function getByClass(oParent, sClass) &#123; var aEle = oParent.getElementsByTagName('*'); var aResult = []; for (var i = 0; i &lt; aEle.length; i++) &#123; if (aEle[i].className = sClass) &#123; aResult.push(aEle[i]); &#125; return aResult; &#125;&#125;window.onload = function() &#123; var con = document.getElementById('container'); var bd = document.getElementById('bd'); var oUl = bd.querySelector('ul'); var oLi = bd.querySelectorAll('li'); var prev = document.getElementById('prev'); var next = document.getElementById('next'); var hd = document.getElementById('hd'); var piont = hd.getElementsByTagName('span'); var nowNav = document.querySelector('.nowNav'); var op = oLi[0].offsetWidth; var move = null; var speed = 0; var now = 0; var navi = 1; document.querySelector('.navig').innerHTML = oLi.length; oUl.style.width = op * oLi.length + 'px'; // 鼠标滑过时停止轮播；滑出式又开始轮播 con.onmouseover = function() &#123; clearInterval(move); &#125;; con.onmouseout = function() &#123; autoMove(); &#125;; // 点击上边的点，跳到相应的页面 for (var i = 0; i &lt; piont.length; i++) &#123; piont[i].index = i; piont[i].onmouseover = function() &#123; // console.log(oUl.offsetLeft); now = this.index; tab(); &#125; &#125; // 点击上边的点，跳到相应的页面函数 function tab() &#123; for (var i = 0; i &lt; piont.length; i++) &#123; piont[i].className = ''; &#125; piont[now].className = 'cur'; startMove(oUl, 'left', -1200 * now); &#125; // 点击向前一页 prev.onclick = function() &#123; speed -= op; if (oUl.offsetLeft &gt;= 0) &#123; speed = 3600; &#125; moving(); now--; if (now == -1) &#123; now = piont.length - 1; &#125; tab(); if (navi &lt; 2) &#123; navi = 5; &#125; nowNav.innerHTML = navi-1; navi--; &#125; // 点击向后一页 next.onclick = function() &#123; speed += op; if (oUl.offsetLeft &lt;= -3600) &#123; speed = 0; &#125; moving(); now++; if (now == piont.length) &#123; now = 0 &#125; tab(); navi++; if (navi &gt; 4) &#123; navi = 1; &#125; nowNav.innerHTML = navi; &#125; // 轮播的函数 function moving() &#123; startMove(oUl, 'left', -speed); &#125; // 自动轮播 轮播间隔时间3000 function autoMove() &#123; move = setInterval(next.onclick, 3000); &#125; autoMove(); html代码如下：123456789101112131415161718192021&lt;div class="container" id="container"&gt; &lt;div id="bd"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="images/0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/3.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="control" id="control"&gt; &lt;span class="prev" id="prev"&gt;&amp;lsaquo;&lt;/span&gt; &lt;span class="next" id="next"&gt;&amp;rsaquo;&lt;/span&gt; &lt;/div&gt; &lt;p class="navigtion"&gt;&lt;span class="nowNav"&gt;1&lt;/span&gt;/&lt;span class="navig"&gt;&lt;/span&gt;&lt;/p&gt; &lt;div id="hd"&gt; &lt;span class="cur"&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; css代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293body &#123; margin: 0; padding: 0; &#125; ul, li &#123; margin: 0; padding: 0; list-style: none; &#125; .container &#123; position: relative; width: 1200px; height: 610px; margin: 150px auto; overflow: hidden; &#125; .container #bd ul, .container #bd li &#123; height: 100%; &#125; .container #bd ul &#123; position: absolute; top: 0; left: 0; &#125; .container #bd li &#123; float: left; width: 1200px; &#125; .container #bd li img &#123; height: 100%; width: 100%; &#125; .control span &#123; position: absolute; top: 0; bottom: 0; z-index: 19; width: 32px; height: 32px; margin: auto; background: #ff0; font-size: 32px; line-height: 30px; text-align: center; cursor: pointer; &#125; .control span.next &#123; right: 0; &#125; #hd &#123; position: absolute; z-index: 29; width: 20%; left: 0; right: 0; margin: auto; bottom: 2%; text-align: center; &#125; #hd span &#123; width: 10px; height: 10px; background: #f00; border-radius: 50%; display: inline-block; cursor: pointer; &#125; #hd .cur &#123; background: #ff0; &#125; .navigtion &#123; position: absolute; bottom: 3%; width: 10%; /* margin: 0 auto; */ display: block; text-align: center; left: 45%; &#125;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现活动倒计时]]></title>
    <url>%2F2016%2F11%2F02%2Fjavascript-add-Date%2F</url>
    <content type="text"><![CDATA[js倒计时 包括天数、时、分、秒 手动填写活动开始/结束时间 javascript 获取当前时间 然后在填写活动开始/结束时间 javascript 代码如下： 12345678910111213141516171819var now = new Date();//获取当前时间function GetServerTime() &#123; var urodz = new Date("11/7/2016 10:00:00"); //填写活动开始/结束时间 now.setTime(now.getTime() + 250); days = (urodz - now) / 1000 / 60 / 60 / 24; //获取天数 daysRound = Math.floor(days); hours = (urodz - now) / 1000 / 60 / 60 - (24 * daysRound); //获取小时 hoursRound = Math.floor(hours); minutes = (urodz - now) / 1000 / 60 - (24 * 60 * daysRound) - (60 * hoursRound); //获取分钟 minutesRound = Math.floor(minutes); seconds = (urodz - now) / 1000 - (24 * 60 * 60 * daysRound) - (60 * 60 * hoursRound) - (60 * minutesRound); //获取秒钟 secondsRound = Math.round(seconds); document.getElementById("date").innerHTML = daysRound; //把时分秒显示出来 document.getElementById("time").innerHTML = hoursRound + "Hours," + minutesRound + "Minutes," + secondsRound + "Seconds";&#125;//保持页面1/4秒重新获取一次 setInterval("GetServerTime()", 250); html代码：123&lt;p class="time"&gt; &lt;span id="date"&gt;&lt;/span&gt;&lt;span class="white14b"&gt;Days,&lt;br/&gt;&lt;/span&gt;&lt;span id="time"&gt;&lt;/span&gt;&lt;/p&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript基本运动框架]]></title>
    <url>%2F2016%2F11%2F01%2Fmy-blog%2F</url>
    <content type="text"><![CDATA[基础的形变 长度、宽度 字体大小 边框宽度 透明度 123456789101112131415161718192021222324252627282930313233//基本的运动动画function getStyle(obj, name) &#123;//获取行内的样式 name表示获取的样式 if (obj.currentStyle) &#123; return obj.currentStyle[name]; &#125; else &#123; return getComputedStyle(obj, false)[name]; &#125; &#125; //运动框架主体function startMove(obj, attr, iTarget) &#123;//attr 变化的样式；iTarget 最后变化目标 clearInterval(obj.timer);//初始化 清除所有的计时器 obj.timer = setInterval(function() &#123; var cur = 0; if (attr == 'opacity') &#123;//如果变化的是透明度 执行下边 cur = parseFloat(getStyle(obj, attr)) * 100; &#125; else &#123; cur = parseInt(getStyle(obj, attr)); &#125; var speed = parseInt(iTarget - cur) / 6;// 动画进行的事件 6可以修改 speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (cur == iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if (attr == 'opacity') &#123;//如果变化的是透明度 执行下边 obj.style.filter = 'alpha(opacity:' + (cur + speed) + ')'; obj.style.opacity = (cur + speed) / 100; &#125; else &#123; obj.style[attr] = cur + speed + 'px'; &#125; &#125; &#125;, 30);&#125; 调用： 123456789//改变宽度oDiv.onmouseover = function () &#123; startMove(this, 'width', 200);&#125;//透明度oDiv.onmouseout = function () &#123; startMove(this, 'opacity', 30);&#125; 颜色的渐变 通过修改元素的rgb值 来实现渐变 1234567891011121314151617181920212223242526272829303132//颜色的渐变动画 改变的是 rgb值//所有代码的执行时间只有24毫秒左右。 function fadeColor(from, to, callback, duration, totalFrames) &#123;//form 初始颜色 to最终颜色 callback完后的回调函数 duration 动画执行时间 totalFrames总帧数，默认为持续秒数*15帧，也即每秒15帧 //用一个函数来包裹setTimeout，根据帧数来确定延时 function doTimeout(color, frame) &#123; setTimeout(function() &#123; try &#123; callback(color); &#125; catch (e) &#123; JSLog.write(e); &#125; &#125;, (duration * 1000 / totalFrames) * frame); //总持续秒数/每秒帧数*当前帧数=延时(秒)，再乘以1000作为延时(毫秒) &#125; // 整个渐变过程的持续时间，默认为1秒 var duration = duration || 1; // 总帧数，默认为持续秒数*15帧，也即每秒15帧 var totalFrames = totalFrames || duration * 15; var r, g, b; var frame = 1; //在第0帧设置起始颜色 doTimeout('rgb(' + from.r + ',' + from.g + ',' + from.b + ')', 0); //计算每次变化所需要改变的rgb值 while (frame &lt; totalFrames + 1) &#123; r = Math.ceil(from.r * ((totalFrames - frame) / totalFrames) + to.r * (frame / totalFrames)); g = Math.ceil(from.g * ((totalFrames - frame) / totalFrames) + to.g * (frame / totalFrames)); b = Math.ceil(from.b * ((totalFrames - frame) / totalFrames) + to.b * (frame / totalFrames)); // 调用本frame的doTimeout doTimeout('rgb(' + r + ',' + g + ',' + b + ')', frame); frame++; &#125;&#125; 调用:123456789101112131415oDiv.onmouseover = function () &#123; fadeColor(&#123; r: 0, g: 0, b: 0 &#125;, //star color &#123; r: 18, g: 162, b: 143 &#125;, //end color function (color) &#123; oDiv6.style.borderColor = color; &#125;, 0.25, 10);&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 在github上部署成功]]></title>
    <url>%2F2016%2F10%2F31%2Fmy-new-post-0%2F</url>
    <content type="text"><![CDATA[终于把本地Hexo部署到github上了，之前不知为什么 就是不成功，今天重新试了一下命令 就成功了 命令为： 发布新文章 首先打开文件夹 hexo，再右键打开Git Bash， 在Git Bash 上执行下列命令： 1hexo new "my new post" //"my new post"为文件名 在hexo文件夹下 source_post 中打开my-new-post.md进行编辑 或者在存放博客的目录下 1hexo n "新建博客的名字" Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：123title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 123456789101112131415layout: 布局 title: 标题 date: 建立日期 文件建立日期updated : 更新日期 文件更新日期comments: 开启文章的评论功能 truetags: 标签（不适用于分页） categories: 分类（不适用于分页） permalink: 覆盖文章网址 举例： 123456title: 标题date: 2016-11-01 11:42:21categories: webtags: [javascript,css] //多个标签用[,]标记description: 这是说明，在首页显示的文字--- 本地预览hexo 本地环境查看时首先打开文件夹 hexo， 在内执行以下命令 1hexo s -p 5000 //后边的-p 5000是修改端口 然后打开浏览器 输如http://localhost:5000/即可查看 部署到GitHub123hexo g //生成静态文件hexo s //在本地预览效果hexo d //同步到github 上 -&gt; 参考&lt;:]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[这是我的第一篇Hexo博客]]></title>
    <url>%2F2016%2F10%2F21%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[一天不独处，我就会变得虚弱。我不以孤独为荣，但我以此为生布考斯基 这是我的第一篇博客，我现在正在熟悉Hexo,所使用的主题是NexT,我觉得这个主题简洁大方，而且里边的缓动效果特别舒服。 我以后会不定时的在这上边更新一些博客，什么类型的都有，写给自己看，写给多年后的自己看。 加油， 每天进步一点，不断努力，终会取得不错的成绩！]]></content>
      <categories>
        <category>个人随写</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2016%2F10%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
