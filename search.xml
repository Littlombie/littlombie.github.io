<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[javascript中定义对象的几种方式]]></title>
      <url>2016%2F11%2F25%2Fjavascript-oop%2F</url>
      <content type="text"><![CDATA[JavaScript中没有类的概念，只有对象。在JavaScript中定义对象可以采用以下几种方式：1.基于已有对象扩充其属性和方法2.工厂方式3.构造函数方式4.原型(“prototype”)方式5.动态原型方式 基于已有对象扩充其属性和方法12345678 var object = new Object(); object.name = "zhangsan"; object.sayName = function(name)&#123; this.name = name; alert(this.name); &#125; object.sayName("lisi");` 这种方式的弊端：这种对象的可复用性不强，如果需要使用多个对象，还需要重新扩展其属性和方法。 工厂方式12345678910111213141516function createObject()&#123; var object = new Object(); object.username = "zhangsan"; object.password = "123"; object.get = function()&#123; alert(this.username + ", " + this.password); &#125; return object;&#125;var object1 = createObject();var object2 = createObject();object1.get();` 改进一：采用带参数的构造方法： 1234567891011121314151617function createObject(username, password)&#123; var object = new Object(); object.username = username; object.password = password; object.get = function()&#123; alert(this.username + ", " + this.password); &#125; return object;&#125;var object1 = createObject("zhangsan", "123");object1.get();` 改进二：让多个对象共享函数对象这样，不用每个对象都生成一个函数对象。 12345678910111213141516171819function get()&#123; alert(this.username + ", " + this.password);&#125;//函数对象只有一份function createObject(username, password)&#123; var object = new Object(); object.username = username; object.password = password; object.get = get; //每一个对象的函数对象都指向同一个函数对象return object;&#125;var object = createObject("zhangsan", "123");var object2 = createObject("lisi", "456");object.get();object2.get(); 优点：让一个函数对象被多个对象所共享，而不是每一个对象拥有一个函数对象。缺点：对象和它的方法定义分开了，可能会造成误解和误用。 构造函数方式构造函数的定义方法其实和普通的自定义函数相同。 123456789101112function Person()&#123; //在执行第一行代码前，js引擎会为我们生成一个对象this.username = "zhangsan"; this.password = "123"; this.getInfo = function()&#123; alert(this.username + ", " + this.password); &#125; //此处有一个隐藏的return语句，用于将之前生成的对象返回//只有在后面用new的情况下，才会出现注释所述的这两点情况&#125;//生成对象var person = new Person();//用了newperson.getInfo(); 改进版：加上参数： 123456789101112function Person(username, password)&#123; this.username = username; this.password = password; this.getInfo = function()&#123; alert(this.username + ", " + this.password); &#125;&#125;var person = new Person("zhangsan", "123");person.getInfo(); 原型(“prototype”)方式例子：12345678910111213141516function Person()&#123;&#125;Person.prototype.username = "zhangsan";Person.prototype.password = "123";Person.prototype.getInfo = function()&#123; alert(this.username + ", " + this.password);&#125;var person = new Person();var person2 = new Person();person.username = "lisi";person.getInfo();person2.getInfo(); 使用原型存在的缺点： 1.不能传参数； 2.有可能会导致程序错误。 如果使用原型方式来定义对象，那么生成的所有对象会共享原型中的属性，这样一个对象改变了该属性也会反映到其他对象当中。单纯使用原型方式定义对象无法在构造函数中为属性赋初值，只能在对象生成后再去改变属性值。 比如，username改为数组后： 123456789101112131415161718function Person()&#123;&#125;Person.prototype.username = new Array();Person.prototype.password = "123";Person.prototype.getInfo = function()&#123; alert(this.username + ", " + this.password);&#125;var person = new Person();var person2 = new Person();person.username.push("zhangsan");person.username.push("lisi");person.password = "456";person.getInfo(); //输出：zhangsan,lisi, 456person2.getInfo(); //输出：zhangsan,lisi, 123//虽然没有对person2对象进行修改，但是它的name和person是一样的，即为zhangsan,lisi 这是因为使用原型方式，person和person2指向的是同一个原型，即对应了同样的属性对象。对于引用类型(比如数组)，两个对象指向了同一个引用，所以对一个所做的更改会影响另一个。而对于字符串(字面常量值)，重新赋值之后就指向了另一个引用，所以二者的修改互不影响。 对原型方式的改进： 使用原型+构造函数方式来定义对象，对象之间的属性互不干扰，各个对象间共享同一个方法。12345678910111213141516171819//使用原型+构造函数方式来定义对象function Person()&#123; this.username = new Array(); this.password = "123";&#125;Person.prototype.getInfo = function()&#123; alert(this.username + ", " + this.password);&#125;var p = new Person();var p2 = new Person();p.username.push("zhangsan");p2.username.push("lisi");p.getInfo();p2.getInfo(); 动态原型方式在构造函数中通过标志量让所有对象共享一个方法，而每个对象拥有自己的属性。 1234567891011121314151617181920212223function Person()&#123; this.username = "zhangsan"; this.password = "123"; if(typeof Person.flag == "undefined")&#123; //此块代码应该只在第一次调用的时候执行 alert("invoked"); Person.prototype.getInfo = function()&#123; //这个方法定义在原型中，会被每一个对象所共同拥有 alert(this.username + ", " + this.password); &#125; Person.flag = true;//第一次定义完之后，之后的对象就不需要再进来这块代码了 &#125;&#125;var p = new Person();var p2 = new Person();p.getInfo();p2.getInfo(); 文章来自网络，如有侵权请联系进行删除，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript 中的 this 详解]]></title>
      <url>2016%2F11%2F25%2Fjavascript-this%2F</url>
      <content type="text"><![CDATA[关于 js 中的 this 文章的一个总结归纳 在 js 中，this 这个上下文总是变化莫测，很多时候出现 bug 总是一头雾水，其实，只要分清楚不同的情况下如何执行就 ok 了。 全局执行 首先，我们在全局环境中看看它的 this 是什么： 浏览器： 123console.log(this);// Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125; node： 123console.log(this); // global 可以看到打印出了 global 对象； 总结 ：在全局作用域中它的 this 执行当前的全局对象（浏览器端是 Window，node 中是 global）。 函数中执行 纯粹的函数调用 这是最普通的函数使用方法了：1234567function test() &#123; console.log(this);&#125;; test(); // Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125; 我们可以看到，一个函数被直接调用的时候，属于全局调用，这时候它的 this 指向 全局对象； 严格模式 ‘use strict’; 如果在严格模式的情况下执行纯粹的函数调用，那么这里的的 this 并不会指向全局，而是 undefined，这样的做法是为了消除 js 中一些不严谨的行为：12345678'use strict';function test() &#123; console.log(this);&#125;; test(); // undefined 当然，把它放在一个立即执行函数中会更好，避免了污染全局：1234567(function ()&#123; "use strict"; console.log(this);&#125;)(); // undefined` 作为对象的方法调用 当一个函数被当作一个对象的方法调用的时候：12345678910var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this.name); &#125;&#125; obj.foo(); // 'qiutc' 这时候，this 指向当前的这个对象； 当然，我们还可以这么做：1234567891011function test() &#123; console.log(this.name);&#125;var obj = &#123; name: 'qiutc', foo: test&#125; obj.foo(); // 'qiutc' 同样不变，因为在 js 中一切都是对象，函数也是一个对象，对于 test ，它只是一个函数名，函数的引用，它指向这个函数，当 foo = test，foo 同样也指向了这个函数。 如果把对象的方法赋值给一个变量，然后直接调用这个变量呢：1234567891011var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;&#125; var test = obj.foo;test(); // Window 可以看到，这时候 this 执行了全局，当我们把 test = obj.foo ，test 直接指向了一个函数的引用，这时候，其实和 obj 这个对象没有关系了，所以，它是被当作一个普通函数来直接调用，因此，this 指向全局对象。 一些坑 我们经常在回调函数里面会遇到一些坑：123456789101112var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;, foo2: function() &#123; console.log(this); setTimeout(this.foo, 1000); &#125;&#125; obj.foo2(); 执行这段代码我们会发现两次打印出来的 this 是不一样的： 第一次是 foo2 中直接打印 this，这里指向 obj 这个对象，我们毋庸置疑； 但是在 setTimeout 中执行的 this.foo ，却指向了全局对象，这里不是把它当作函数的方法使用吗？这一点经常让很多初学者疑惑； 其实，setTimeout 也只是一个函数而已，函数必然有可能需要参数，我们把 this.foo 当作一个参数传给 setTimeout 这个函数，就像它需要一个 fun 参数，在传入参数的时候，其实做了个这样的操作 fun = this.foo，看到没有，这里我们直接把 fun 指向 this.foo 的引用；执行的时候其实是执行了 fun() 所以已经和 obj 无关了，它是被当作普通函数直接调用的，因此 this 指向全局对象。 这个问题是很多异步回调函数中普遍会碰到的； 解决 为了解决这个问题，我们可以利用 闭包 的特性来处理：12345678910111213141516var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;, foo2: function() &#123; console.log(this); var _this = this; setTimeout(function() &#123; console.log(this); // Window console.log(_this); // Object &#123;name: "qiutc"&#125; &#125;, 1000); &#125;&#125; obj.foo2(); 可以看到直接用 this 仍然是 Window；因为 foo2 中的 this 是指向 obj，我们可以先用一个变量 _this 来储存，然后在回调函数中使用_this，就可以指向当前的这个对象了； setTimeout 的另一个坑 之前啊说过，如果直接执行回调函数而没有绑定作用域，那么它的 this 是指向全局对象(window)，在严格模式下会指向 undefined，然而在 setTimeout 中的回调函数在严格模式下却表现出不同：123456789'use strict'; function foo() &#123; console.log(this);&#125; setTimeout(foo, 1); // window 按理说我们加了严格模式，foo 调用也没有指定 this，应该是出来 undefined，但是这里仍然出现了全局对象，难道是严格模式失效了吗？ 并不，即使在严格模式下，setTimeout 方法在调用传入函数的时候，如果这个函数没有指定了的 this，那么它会做一个隐式的操作—-自动地注入全局上下文，等同于调用 foo.apply(window) 而非 foo()； 当然，如果我们在传入函数的时候已经指定 this，那么就不会被注入全局对象，比如： setTimeout(foo.bind(obj), 1);； http://stackoverflow.com/questions/21957030/why-is-window-still-defined-in-this-strict-mode-code 作为一个构造函数使用 在 js 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候需要加上 new 这个关键字： 12345678function Person(name) &#123; this.name = name; console.log(this);&#125; var p = new Person('qiutc'); // Person &#123;name: "qiutc"&#125; 我们可以看到当作构造函数调用时，this 指向了这个构造函数调用时候实例化出来的对象； 当然，构造函数其实也是一个函数，如果我们把它当作一个普通函数执行，这个 this 仍然执行全局：12345678function Person(name) &#123; this.name = name; console.log(this);&#125; var p = Person('qiutc'); // Window 其区别在于，如何调用函数（new）。 箭头函数 在 ES6 的新规范中，加入了箭头函数，它和普通函数最不一样的一点就是this 的指向了，还记得在上文中（作为对象的方法调用-一些坑-解决）我们使用闭包来解决 this 的指向问题吗，如果用上了箭头函数就可以更完美的解决了： 1234567891011121314var obj = &#123; name: 'qiutc', foo: function() &#123; console.log(this); &#125;, foo2: function() &#123; console.log(this); setTimeout(() =&gt; &#123; console.log(this); // Object &#123;name: "qiutc"&#125; &#125;, 1000); &#125;&#125; obj.foo2(); 可以看到，在 setTimeout 执行的函数中，本应该打印出在 Window，但是在这里 this 却指向了 obj，原因就在于，给 setTimeout 传入的函数（参数）是一个箭头函数： 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 根据例子我们理解一下这句话： 在 obj.foo2() 执行的时候，当前的 this 指向 obj；在执行 setTimeout 时候，我们先是定义了一个匿名的箭头函数，关键点就在这，箭头函数内的 this 执行定义时所在的对象，就是指向定义这个箭头函数时作用域内的 this，也就是 obj.foo2 中的 this，即 obj；所以在执行箭头函数的时候，它的 this -&gt; obj.foo2 中的 this -&gt; obj；，简单来说， 箭头函数中的 this 只和定义它时候的作用域的 this 有关而与在哪里以及如何调用它无关，同时它的 this 指向是不可改变的。 call, apply, bind 在 js 中，函数也是对象，同样也有一些方法，这里我们介绍三个方法，他们可以更改函数中的 this 指向： call 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，后面的参数是执行函数需要传入的参数； apply 1fun.apply(thisArg[, [arg1, arg2, ...]]) 它会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）； bind 1var foo = fun.bind(thisArg[, arg1[, arg2[, ...]]]); 它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数； 这三个函数其实大同小异，总的目的就是去指定一个函数的上下文（this），我们以 call 函数为例； 为一个普通函数指定 this1234567891011var obj = &#123; name: 'qiutc'&#125;; function foo() &#123; console.log(this);&#125; foo.call(obj); // Object &#123;name: "qiutc"&#125; 可以看到，在执行 foo.call(obj) 的时候，函数内的 this 指向了 obj 这个对象，成功； 为对象中的方法指定一个 this 1234567891011121314var obj = &#123; name: 'qiutc', foo: function () &#123; console.log(this); &#125;&#125; var obj2 = &#123; name: 'tcqiu222222'&#125;; obj.foo.call(obj2); // Object &#123;name: "tcqiu222222"&#125; 可以看到，执行函数的时候这里的 this 指向了 obj2，成功； 为构造函数指定 this123456789101112function Person(name) &#123; this.name = name; console.log(this);&#125; var obj = &#123; name: 'qiutc2222222'&#125;; var p = new Person.call(obj, 'qiutc'); // Uncaught TypeError: Person.call is not a constructor(…) 这里报了个错，原因是我们去 new 了 Person.call 函数，而非 Person ，这里的函数不是一个构造函数； 换成 bind 试试： 123456789101112131415161718function Person(name) &#123; this.name = name; console.log(this);&#125; var obj = &#123; name: 'qiutc2222222'&#125;; var Person2 = Person.bind(obj); var p = new Person2('qiutc'); // Person &#123;name: "qiutc"&#125; console.log(obj); // Object &#123;name: "qiutc2222222"&#125; 打印出来的是 Person 实例化出来的对象，而和 obj 没有关系，而 obj 也没有发生变化，说明，我们给 Person 指定 this 上下文并没有生效； 因此可以得出： 使用 bind 给一个构造函数指定 this，在 new 这个构造函数的时候，bind 函数所指定的 this 并不会生效； 当然 bind 不仅可以指定this ，还能传入参数，我们来试试这个操作： 1234567891011121314function Person(name) &#123; this.name = name; console.log(this);&#125; var obj = &#123; name: 'qiutc2222222'&#125;; var Person2 = Person.bind(obj, 'qiutc111111'); var p = new Person2('qiutc'); // Person &#123;name: "qiutc111111"&#125; 可以看到，虽然指定 this 不起作用，但是传入参数还是起作用了； 为箭头函数指定 this 我们来定义一个全局下的箭头函数，因此这个箭头函数中的 this 必然会指向全局对象，如果用 call 方法改变 this 呢：123456789101112131415161718var afoo = (a) =&gt; &#123; console.log(a); console.log(this);&#125; afoo(1); // 1// Window var obj = &#123; name: 'qiutc'&#125;; afoo.call(obj, 2); // 2// Window 可以看到，这里的call 指向 this 的操作并没有成功，所以可以得出： 箭头函数中的 this 在定义它的时候已经决定了（执行定义它的作用域中的 this），与如何调用以及在哪里调用它无关，包括 (call, apply, bind) 等操作都无法改变它的 this 。 只要记住箭头函数大法好，不变的 this。 文章来源qiutc.me，如有侵权请联系进行删除，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[深入javascript——构造函数和原型对象]]></title>
      <url>2016%2F11%2F18%2Fjavascript-Object%2F</url>
      <content type="text"><![CDATA[常用的几种对象创建模式 使用new关键字创建 最基础的对象创建方式，无非就是和其他多数语言一样说的一样：没对象，你new一个呀！123456var gf = new Object();gf.name = "zhangSan";gf.bar = "c++";gf.sayWhat = function() &#123; console.log(this.name + "said:love you forever");&#125; 使用字面量创建 这样似乎妥妥的了，但是宅寂的geek们岂能喜欢如此复杂和low土的定义变量的方式，作为一门脚本语言那应该有和其他兄弟们一样的范儿，于是出现了对象字面量的定义方式： 1234567var gf = &#123; name : "zhangSan", bar : "c++", sayWhat : function() &#123; console.log(this.name + "said:love you forever"); &#125;&#125; 工厂模式 实际上这是我们在实际中最常用的对象定义方式，但是我要有好多拥有相似属性的对象（想想都让人激动。。。）怎么办呢？那要是一个个的定义，就会产生 大量的代码，何不建个工厂，批量的生产出我们的对象呢，于是，javascript世界中第一个充气娃。。。不，“工厂模式”诞生了！ 1234567891011function createGf(name, bar) &#123; var o = new Object(); o.name = name; o.bar = bar; o.sayWhat = function() &#123; alert(this.name + "said:love you forever"); &#125; return o;&#125;var gf1 = createGf("bingbing","d");var gf2 = createGf("mimi","a"); 构造函数 工厂模式解决了多个相似对象的创建问题，但是问题又来了，这些对象都是Object整出来的，怎么区分它们的对象具体类型呢？这时候我们就需要切换到另一种模式了，构造函数模式： 12345678910function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = function()&#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf("vivian","f");var gf2 = new Gf("vivian2","f");` 这里我们使用一个大写字母开头的构造函数替代了上例中的createGf，注意按照约定构造函数的首字母要大写。在这里我们创建一个新对象，然后将构造函数的作用域赋给新对象，调用构造函数中的方法。 上面的方式似乎没什么不妥，但是我们可以发现，两个实例中调用的构造函数中的sayWhat方法不是同一个Function实例：1console.log(gf1.sayWhat == gf2.sayWhat); //false 调用同一个方法，却声明了不同的实例，实在浪费资源。我们可以优化一下将sayWhat函数放到构造函数外面声明：12345678function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = sayWhat&#125;function sayWhat()&#123; alert(this.name + "said:love you forever");&#125; 这样解决了，多个实例多次定义同一个方法实例的问题，但是新问题又来了，我们定义的sayWhat是一个全局作用域的方法，但这个方法其实是没法直接调用的，这就有点矛盾了。如何更优雅的定义一个具备一定封装性的对象呢？我们来看一下javascript原型对象模式。 原型对象模式 理解原型对象 当我们创建一个函数时，该函数就会具备一个prototype属性，这个属性指向通过构造函数创建的那个函数的原型对象。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象。 在原型模式中，不必再构造函数中定义实例属性，可以将属性信息直接赋予原型对象：12345678910function Gf()&#123; Gf.prototype.name = "vivian"; Gf.prototype.bar = "c++"; Gf.prototype.sayWhat = function()&#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf();gf1.sayWhat();var gf2 = new Gf(); 和构造函数不同的是这里新对象的属性和方法是所有实例都可以共享的，换句话说gf1和gf2访问的是同一份属性和方法。原型对象中除了我们赋予的属性外，还有一些内置的属性，所有原型对象都具备一个constructor属性，这个属性是一个指向包含prototype属性函数的一个指针（敢不敢再绕点！）。通过一幅图我们来清楚的理一下这个绕口的流程： 所有的对象都有一个原型对象（prototype），原型对象中有一个constructor属性指向包含prototype属性的函数，Gf的实例gf1和gf2都包含一个内部属性指向原型对象（在firefox浏览器中表现为私有属性proto），当我们访问一个对象中的属性时，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象。 使用原型对象 在前面的示例中，我们注意到在为原型对象添加属性时，需要每个都增加Gf.prototype，这个工作很重复，在上面对象的创建模式中，我们知道可以通过字面量的形式创建一个对象，这里我们也可以改进一下： 12345678function Gf()&#123;&#125;Gf.prototype = &#123; name : "vivian", bar : "c++", sayWhat : function()&#123; alert(this.name + "said:love you forever"); &#125;&#125; 这里有一个地方需要特别注意下，constructor属性不再指向对象Gf，因为每定义一个函数，就会同时为其创建一个prototype对象，这个对象也会自动获取一个新的constructor属性，这个地方我们使用Gf.prototype本质上覆写了原有的prototype对象，因此constructor也变成了新对象的constructor属性，不再指向Gf，而是Object:123var gf1 = new Gf();console.log(gf1.constructor == Gf);//falseconsole.log(gf1.constructor == Object)//true 一般情况下，这个微妙的改变是不会对我们造成影响的，但如果你对constructor有特殊的需求，我们也可以显式的指定下Gf.prototype的constructor属性：12345678910Gf.prototype = &#123; constructor : Gf, name : "vivian", bar : "c++", sayWhat : function() &#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf();console.log(gf1.constructor == Gf);//true 通过对原型对象模式的初步了解，我们发现所有的实例对象都共享相同的属性，这是原型模式的基本特点，但往往对于开发者来说这是把“双刃剑”，在实际开发中，我们希望的实例应该是具备自己的属性，这也是在实际开发中很少有人单独使用原型模式的主要原因。 构造函数和原型组合模式 在实际开发中，我们可以使用构造函数来定义对象的属性，使用原型来定义共享的属性和方法，这样我们就可以传递不同的参数来创建出不同的对象，同时又拥有了共享的方法和属性。 123456789101112function Gf(name,bar)&#123; this.name = name; this.bar = bar;&#125;Gf.prototype = &#123; constructor : Gf, sayWhat : function() &#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf("vivian", "f");var gf2 = new Gf("vivian1", "c"); 在这个例子中，我们再构造函数中定义了对象各自的属性值，在原型对象中定义了constructor属性和sayWhat函数，这样gf1和gf2属性之 间就不会产生影响了。这种模式也是实际开发中最常用的对象定义方式，包括很多js库（bootstrap等）默认的采用的模式。 *文章来自网络，如有侵权请联系进行删除，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[周末随拍（2016.11.13）]]></title>
      <url>2016%2F11%2F16%2Fthe-Accompanying-photograph%2F</url>
      <content type="text"><![CDATA[兴庆公园 兴庆公园 兴庆公园 兴庆公园 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔 小寨 #拍摄来自魅蓝E#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git 上传本地文件到github]]></title>
      <url>2016%2F11%2F12%2Fupload-git-for-github%2F</url>
      <content type="text"><![CDATA[Git 上传本地文件到github 1 git config –global user.name “Your Real Name” 2 git config –global user.email you@email.address 1234567git initgit add .git commit -m 'Test'git remote add origin git@github.com:XXX/XXX.git 3 git push -u origin master 一些可能遇到的问题解决： 如果输入$ git remote add origingit@github.com:djqiang（github帐号名）/gitdemo（项目名）.git提示出错信息：fatal: remote origin already exists. 解决办法如下： 1、先输入$ git remote rm origin 2、再输入$ git remote add origin git@github.com:djqiang/gitdemo.git 就不会报错了！ 3、如果输入$ git remote rm origin 还是报错的话，error: Could not remove config section ‘remote.origin’.我们需要修改gitconfig文件的内容 4、找到你的github的安装路径，我的是 1C:\Users\ASUS\AppData\Local\GitHub\PortableGit_ca477551eeb4aea0e4ae9fcd3358bd96720bb5c8\etc 5、找到一个名为gitconfig的文件，打开它把里面的[remote &quot;origin&quot;]那一行删掉就好了！如果输入$ ssh -T git@github.com 出现错误提示：Permission denied(publickey).因为新生成的key不能加入ssh就会导致连接不上github。 解决办法如下： 1、先输入$ ssh-agent，再输入$ ssh-add ~/.ssh/id_key，这样就可以了。 2、如果还是不行的话，输入ssh-add ~/.ssh/id_key 命令后出现报错Could not open a connection to your authentication agent.解决方法是key用GitGui的ssh工具生成，这样生成的时候key就直接保存在ssh中了，不需要再ssh-add命令加入了，其它的user，token等配置都用命令行来做。 3、最好检查一下在你复制id_rsa.pub文件的内容时有没有产生多余的空格或空行，有些编辑器会帮你添加这些的。 如果输入$ git push origin master 提示出错信息：error:failed to push som refs to ……. 解决办法如下： 1、先输入$ git pull origin master //先把远程服务器github上面的文件拉下来 2、再输入$ git push origin master 3、如果出现报错 fatal: Couldn’t find remote ref master或者fatal: ‘origin’ does not appear to be a git repository以及fatal: Could not read from remote repository. 4、则需要重新输入$ git remote add origingit@github.com:djqiang/gitdemo.git 使用git在本地创建一个项目的过程12345678$ makdir ~/hello-world //创建一个项目hello-world$ cd ~/hello-world //打开这个项目$ git init //初始化$ touch README$ git add README //更新README文件$ git commit -m ‘first commit’ //提交更新，并注释信息“first commit”$ git remote add origin git@github.com:defnngj/hello-world.git //连接远程github项目$ git push -u origin master //将本地项目更新到github项目上去 我的github 同步测试： 1234567891011echo "# text" &gt;&gt; README.mdgit initgit add README.mdgit commit -m "first commit"git remote add origin https://github.com/Littlombie/text.gitgit push -u origin master…or push an existing repository from the command linegit remote add origin https://github.com/Littlombie/text.gitgit push -u origin master]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3导航动画切换]]></title>
      <url>2016%2F11%2F09%2FRotate-the-navigation%2F</url>
      <content type="text"><![CDATA[我们浏览有些手机网站时，有时会发现页面的导航打开动画很有意思，类似下图这种： 现在我们用html input表单以及css3实现这个功能，原理如下： html为用input 与label表单，label下边三个div表示导航的三条横线； 当点击label时，input会选中,与之对应的label下边三个div执行动画,其中第二个div让宽度为0，位置发生变化，第一个与第三个div执行旋转动画，形成×； 再次点击取消选中时，利用input的属性，恢复到选中之前的状态。 html代码如下： 12345678&lt;div class="nav_bar"&gt; &lt;input type="checkbox" id="nemu_button"&gt; &lt;label for="nemu_button"&gt; &lt;div class="line_top transition"&gt;&lt;/div&gt; &lt;div class="line_meddle transition"&gt;&lt;/div&gt; &lt;div class="line_bottom transition"&gt;&lt;/div&gt; &lt;/label&gt;&lt;/div&gt; css代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*过渡动画transition*/.transition &#123; -webkit-transition: all .25s ease-in-out; -moz-transition: all .25s ease-in-out; -ms-transition: all .25s ease-in-out; -o-transition: all .25s ease-in-out; transition: all .25s ease-in-out;&#125;#nemu_button &#123; position: absolute; left: 9999px;&#125;label &#123; position: absolute; right:50px; cursor:pointer;&#125;label&gt;div &#123; width: 30px; height: 2px; margin-bottom: 8px; background: #fff;&#125;/*input选中是 label下边的三条横线的过渡动画*/input:checked + label .line_top &#123; margin-top: 15px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);&#125;input:checked + label .line_meddle &#123; width: 0; margin-top: -15px; margin-left: 15px;&#125;input:checked + label .line_bottom &#123; margin-top: -5px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数字化Loading]]></title>
      <url>2016%2F11%2F07%2FLoading-Page%2F</url>
      <content type="text"><![CDATA[js页面从0~100%的loading； javascript代码： 12345678910111213141516171819function setSB(v, el) &#123; //判断页面是否加载完成 if (document.readyState == "complete") &#123; valueEl = el.children[0]; valueEl.innerText = v + "%";//显示百分比 &#125; &#125; function fakeProgress(v, el) &#123; if (v &gt; 100)&#123;//加载完成 document.querySelector('#text').innerHTML="加载完成"; setTimeout(function()&#123; document.querySelector('#sb').style.display="none"; &#125;,200); &#125; else &#123; setSB(v, el); window.setTimeout("fakeProgress(" + (++v) + ", document.all['" + el.id + "'])", 20); &#125; &#125; html代码： 123456789&lt;body onload="fakeProgress(0, sb)"&gt; &lt;center&gt; &lt;p id="text"&gt;正在载入中，请稍侯……&lt;/p&gt; &lt;span id='sb' style="width: 302px"&gt; &lt;div&gt;&lt;/div&gt; &lt;div style="font-size: 9pt; width: 100%; text-align: center"&gt;&lt;/div&gt; &lt;/span&gt; &lt;/center&gt;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js轮播图(适用于PC)]]></title>
      <url>2016%2F11%2F03%2F20161103js-Slider%2F</url>
      <content type="text"><![CDATA[实现自动左右轮播 鼠标移入停止轮播，鼠标移开继续轮播 prev next点击左右切换 点击下边导航可以跳转到相应的页 首先引入自己封装的简单的js运动库 move.js1&lt;script src="move.js"&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132function getStyle(obj, name) &#123; if (obj.currentStyle) &#123; return obj.currentStyle[name]; &#125; else &#123; return getComputedStyle(obj, false)[name]; &#125; &#125; function startMove(obj, attr, iTarget) &#123; clearInterval(obj.timer); obj.timer = setInterval(function() &#123; var cur = 0; if (attr == 'opacity') &#123; cur = parseFloat(getStyle(obj, attr)) * 100; &#125; else &#123; cur = parseInt(getStyle(obj, attr)); &#125; var speed = parseInt(iTarget - cur) / 6; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (cur == iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if (attr == 'opacity') &#123; obj.style.filter = 'alpha(opacity:' + (cur + speed) + ')'; obj.style.opacity = (cur + speed) / 100; &#125; else &#123; obj.style[attr] = cur + speed + 'px'; &#125; &#125; &#125;, 30); &#125; javascript代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function getByClass(oParent, sClass) &#123; var aEle = oParent.getElementsByTagName('*'); var aResult = []; for (var i = 0; i &lt; aEle.length; i++) &#123; if (aEle[i].className = sClass) &#123; aResult.push(aEle[i]); &#125; return aResult; &#125;&#125;window.onload = function() &#123; var con = document.getElementById('container'); var bd = document.getElementById('bd'); var oUl = bd.querySelector('ul'); var oLi = bd.querySelectorAll('li'); var prev = document.getElementById('prev'); var next = document.getElementById('next'); var hd = document.getElementById('hd'); var piont = hd.getElementsByTagName('span'); var nowNav = document.querySelector('.nowNav'); var op = oLi[0].offsetWidth; var move = null; var speed = 0; var now = 0; var navi = 1; document.querySelector('.navig').innerHTML = oLi.length; oUl.style.width = op * oLi.length + 'px'; // 鼠标滑过时停止轮播；滑出式又开始轮播 con.onmouseover = function() &#123; clearInterval(move); &#125;; con.onmouseout = function() &#123; autoMove(); &#125;; // 点击上边的点，跳到相应的页面 for (var i = 0; i &lt; piont.length; i++) &#123; piont[i].index = i; piont[i].onmouseover = function() &#123; // console.log(oUl.offsetLeft); now = this.index; tab(); &#125; &#125; // 点击上边的点，跳到相应的页面函数 function tab() &#123; for (var i = 0; i &lt; piont.length; i++) &#123; piont[i].className = ''; &#125; piont[now].className = 'cur'; startMove(oUl, 'left', -1200 * now); &#125; // 点击向前一页 prev.onclick = function() &#123; speed -= op; if (oUl.offsetLeft &gt;= 0) &#123; speed = 3600; &#125; moving(); now--; if (now == -1) &#123; now = piont.length - 1; &#125; tab(); if (navi &lt; 2) &#123; navi = 5; &#125; nowNav.innerHTML = navi-1; navi--; &#125; // 点击向后一页 next.onclick = function() &#123; speed += op; if (oUl.offsetLeft &lt;= -3600) &#123; speed = 0; &#125; moving(); now++; if (now == piont.length) &#123; now = 0 &#125; tab(); navi++; if (navi &gt; 4) &#123; navi = 1; &#125; nowNav.innerHTML = navi; &#125; // 轮播的函数 function moving() &#123; startMove(oUl, 'left', -speed); &#125; // 自动轮播 轮播间隔时间3000 function autoMove() &#123; move = setInterval(next.onclick, 3000); &#125; autoMove(); html代码如下：123456789101112131415161718192021&lt;div class="container" id="container"&gt; &lt;div id="bd"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="images/0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/3.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="control" id="control"&gt; &lt;span class="prev" id="prev"&gt;&amp;lsaquo;&lt;/span&gt; &lt;span class="next" id="next"&gt;&amp;rsaquo;&lt;/span&gt; &lt;/div&gt; &lt;p class="navigtion"&gt;&lt;span class="nowNav"&gt;1&lt;/span&gt;/&lt;span class="navig"&gt;&lt;/span&gt;&lt;/p&gt; &lt;div id="hd"&gt; &lt;span class="cur"&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; css代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293body &#123; margin: 0; padding: 0; &#125; ul, li &#123; margin: 0; padding: 0; list-style: none; &#125; .container &#123; position: relative; width: 1200px; height: 610px; margin: 150px auto; overflow: hidden; &#125; .container #bd ul, .container #bd li &#123; height: 100%; &#125; .container #bd ul &#123; position: absolute; top: 0; left: 0; &#125; .container #bd li &#123; float: left; width: 1200px; &#125; .container #bd li img &#123; height: 100%; width: 100%; &#125; .control span &#123; position: absolute; top: 0; bottom: 0; z-index: 19; width: 32px; height: 32px; margin: auto; background: #ff0; font-size: 32px; line-height: 30px; text-align: center; cursor: pointer; &#125; .control span.next &#123; right: 0; &#125; #hd &#123; position: absolute; z-index: 29; width: 20%; left: 0; right: 0; margin: auto; bottom: 2%; text-align: center; &#125; #hd span &#123; width: 10px; height: 10px; background: #f00; border-radius: 50%; display: inline-block; cursor: pointer; &#125; #hd .cur &#123; background: #ff0; &#125; .navigtion &#123; position: absolute; bottom: 3%; width: 10%; /* margin: 0 auto; */ display: block; text-align: center; left: 45%; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js实现活动倒计时]]></title>
      <url>2016%2F11%2F02%2Fjavascript-add-Date%2F</url>
      <content type="text"><![CDATA[js倒计时 包括天数、时、分、秒 手动填写活动开始/结束时间 javascript 获取当前时间 然后在填写活动开始/结束时间 javascript 代码如下： 12345678910111213141516171819var now = new Date();//获取当前时间function GetServerTime() &#123; var urodz = new Date("11/7/2016 10:00:00"); //填写活动开始/结束时间 now.setTime(now.getTime() + 250); days = (urodz - now) / 1000 / 60 / 60 / 24; //获取天数 daysRound = Math.floor(days); hours = (urodz - now) / 1000 / 60 / 60 - (24 * daysRound); //获取小时 hoursRound = Math.floor(hours); minutes = (urodz - now) / 1000 / 60 - (24 * 60 * daysRound) - (60 * hoursRound); //获取分钟 minutesRound = Math.floor(minutes); seconds = (urodz - now) / 1000 - (24 * 60 * 60 * daysRound) - (60 * 60 * hoursRound) - (60 * minutesRound); //获取秒钟 secondsRound = Math.round(seconds); document.getElementById("date").innerHTML = daysRound; //把时分秒显示出来 document.getElementById("time").innerHTML = hoursRound + "Hours," + minutesRound + "Minutes," + secondsRound + "Seconds";&#125;//保持页面1/4秒重新获取一次 setInterval("GetServerTime()", 250); html代码：123&lt;p class="time"&gt; &lt;span id="date"&gt;&lt;/span&gt;&lt;span class="white14b"&gt;Days,&lt;br/&gt;&lt;/span&gt;&lt;span id="time"&gt;&lt;/span&gt;&lt;/p&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基本运动框架]]></title>
      <url>2016%2F11%2F01%2Fmy-blog%2F</url>
      <content type="text"><![CDATA[基础的形变 长度、宽度 字体大小 边框宽度 透明度 123456789101112131415161718192021222324252627282930313233//基本的运动动画function getStyle(obj, name) &#123;//获取行内的样式 name表示获取的样式 if (obj.currentStyle) &#123; return obj.currentStyle[name]; &#125; else &#123; return getComputedStyle(obj, false)[name]; &#125; &#125; //运动框架主体function startMove(obj, attr, iTarget) &#123;//attr 变化的样式；iTarget 最后变化目标 clearInterval(obj.timer);//初始化 清除所有的计时器 obj.timer = setInterval(function() &#123; var cur = 0; if (attr == 'opacity') &#123;//如果变化的是透明度 执行下边 cur = parseFloat(getStyle(obj, attr)) * 100; &#125; else &#123; cur = parseInt(getStyle(obj, attr)); &#125; var speed = parseInt(iTarget - cur) / 6;// 动画进行的事件 6可以修改 speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (cur == iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if (attr == 'opacity') &#123;//如果变化的是透明度 执行下边 obj.style.filter = 'alpha(opacity:' + (cur + speed) + ')'; obj.style.opacity = (cur + speed) / 100; &#125; else &#123; obj.style[attr] = cur + speed + 'px'; &#125; &#125; &#125;, 30);&#125; 调用： 123456789//改变宽度oDiv.onmouseover = function () &#123; startMove(this, 'width', 200);&#125;//透明度oDiv.onmouseout = function () &#123; startMove(this, 'opacity', 30);&#125; 颜色的渐变 通过修改元素的rgb值 来实现渐变 1234567891011121314151617181920212223242526272829303132//颜色的渐变动画 改变的是 rgb值//所有代码的执行时间只有24毫秒左右。 function fadeColor(from, to, callback, duration, totalFrames) &#123;//form 初始颜色 to最终颜色 callback完后的回调函数 duration 动画执行时间 totalFrames总帧数，默认为持续秒数*15帧，也即每秒15帧 //用一个函数来包裹setTimeout，根据帧数来确定延时 function doTimeout(color, frame) &#123; setTimeout(function() &#123; try &#123; callback(color); &#125; catch (e) &#123; JSLog.write(e); &#125; &#125;, (duration * 1000 / totalFrames) * frame); //总持续秒数/每秒帧数*当前帧数=延时(秒)，再乘以1000作为延时(毫秒) &#125; // 整个渐变过程的持续时间，默认为1秒 var duration = duration || 1; // 总帧数，默认为持续秒数*15帧，也即每秒15帧 var totalFrames = totalFrames || duration * 15; var r, g, b; var frame = 1; //在第0帧设置起始颜色 doTimeout('rgb(' + from.r + ',' + from.g + ',' + from.b + ')', 0); //计算每次变化所需要改变的rgb值 while (frame &lt; totalFrames + 1) &#123; r = Math.ceil(from.r * ((totalFrames - frame) / totalFrames) + to.r * (frame / totalFrames)); g = Math.ceil(from.g * ((totalFrames - frame) / totalFrames) + to.g * (frame / totalFrames)); b = Math.ceil(from.b * ((totalFrames - frame) / totalFrames) + to.b * (frame / totalFrames)); // 调用本frame的doTimeout doTimeout('rgb(' + r + ',' + g + ',' + b + ')', frame); frame++; &#125;&#125; 调用:123456789101112131415oDiv.onmouseover = function () &#123; fadeColor(&#123; r: 0, g: 0, b: 0 &#125;, //star color &#123; r: 18, g: 162, b: 143 &#125;, //end color function (color) &#123; oDiv6.style.borderColor = color; &#125;, 0.25, 10);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 在github上部署成功]]></title>
      <url>2016%2F10%2F31%2Fmy-new-post-0%2F</url>
      <content type="text"><![CDATA[终于把本地Hexo部署到github上了，之前不知为什么 就是不成功，今天重新试了一下命令 就成功了 命令为： 发布新文章 首先打开文件夹 hexo，再右键打开Git Bash， 在Git Bash 上执行下列命令： 1hexo new "my new post" //"my new post"为文件名 在hexo文件夹下 source_post 中打开my-new-post.md进行编辑 或者在存放博客的目录下 1hexo n "新建博客的名字" Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：123title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 123456789101112131415layout: 布局 title: 标题 date: 建立日期 文件建立日期updated : 更新日期 文件更新日期comments: 开启文章的评论功能 truetags: 标签（不适用于分页） categories: 分类（不适用于分页） permalink: 覆盖文章网址 举例： 123456title: 标题date: 2016-11-01 11:42:21categories: webtags: [javascript,css] //多个标签用[,]标记description: 这是说明，在首页显示的文字--- 本地预览hexo 本地环境查看时首先打开文件夹 hexo， 在内执行以下命令 1hexo s -p 5000 //后边的-p 5000是修改端口 然后打开浏览器 输如http://localhost:5000/即可查看 部署到GitHub123hexo g //生成静态文件hexo s //在本地预览效果hexo d //同步到github 上 -&gt; 参考&lt;:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[这是我的第一篇Hexo博客]]></title>
      <url>2016%2F10%2F21%2FMy-New-Post%2F</url>
      <content type="text"><![CDATA[一天不独处，我就会变得虚弱。我不以孤独为荣，但我以此为生 布考斯基 这是我的第一篇博客，我现在正在熟悉Hexo,所使用的主题是NexT,我觉得这个主题简洁大方，而且里边的缓动效果特别舒服。 我以后会不定时的在这上边更新一些博客，什么类型的都有，写给自己看，写给多年后的自己看。 加油， 每天进步一点，不断努力，终会取得不错的成绩！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>2016%2F10%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
