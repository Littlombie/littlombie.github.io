<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[深入javascript——构造函数和原型对象]]></title>
      <url>2016%2F11%2F18%2Fjavascript-Object%2F</url>
      <content type="text"><![CDATA[常用的几种对象创建模式 使用new关键字创建 最基础的对象创建方式，无非就是和其他多数语言一样说的一样：没对象，你new一个呀！123456var gf = new Object();gf.name = "zhangSan";gf.bar = "c++";gf.sayWhat = function() &#123; console.log(this.name + "said:love you forever");&#125; 使用字面量创建 这样似乎妥妥的了，但是宅寂的geek们岂能喜欢如此复杂和low土的定义变量的方式，作为一门脚本语言那应该有和其他兄弟们一样的范儿，于是出现了对象字面量的定义方式： 1234567var gf = &#123; name : "zhangSan", bar : "c++", sayWhat : function() &#123; console.log(this.name + "said:love you forever"); &#125;&#125; 工厂模式 实际上这是我们在实际中最常用的对象定义方式，但是我要有好多拥有相似属性的对象（想想都让人激动。。。）怎么办呢？那要是一个个的定义，就会产生 大量的代码，何不建个工厂，批量的生产出我们的对象呢，于是，javascript世界中第一个充气娃。。。不，“工厂模式”诞生了！ 1234567891011function createGf(name, bar) &#123; var o = new Object(); o.name = name; o.bar = bar; o.sayWhat = function() &#123; alert(this.name + "said:love you forever"); &#125; return o;&#125;var gf1 = createGf("bingbing","d");var gf2 = createGf("mimi","a"); 构造函数 工厂模式解决了多个相似对象的创建问题，但是问题又来了，这些对象都是Object整出来的，怎么区分它们的对象具体类型呢？这时候我们就需要切换到另一种模式了，构造函数模式： 12345678910function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = function()&#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf("vivian","f");var gf2 = new Gf("vivian2","f");` 这里我们使用一个大写字母开头的构造函数替代了上例中的createGf，注意按照约定构造函数的首字母要大写。在这里我们创建一个新对象，然后将构造函数的作用域赋给新对象，调用构造函数中的方法。 上面的方式似乎没什么不妥，但是我们可以发现，两个实例中调用的构造函数中的sayWhat方法不是同一个Function实例：1console.log(gf1.sayWhat == gf2.sayWhat); //false 调用同一个方法，却声明了不同的实例，实在浪费资源。我们可以优化一下将sayWhat函数放到构造函数外面声明：12345678function Gf(name,bar)&#123; this.name = name; this.bar = bar; this.sayWhat = sayWhat&#125;function sayWhat()&#123; alert(this.name + "said:love you forever");&#125; 这样解决了，多个实例多次定义同一个方法实例的问题，但是新问题又来了，我们定义的sayWhat是一个全局作用域的方法，但这个方法其实是没法直接调用的，这就有点矛盾了。如何更优雅的定义一个具备一定封装性的对象呢？我们来看一下javascript原型对象模式。 原型对象模式 理解原型对象 当我们创建一个函数时，该函数就会具备一个prototype属性，这个属性指向通过构造函数创建的那个函数的原型对象。通俗点讲原型对象就是内存中为其他对象提供共享属性和方法的对象。 在原型模式中，不必再构造函数中定义实例属性，可以将属性信息直接赋予原型对象：12345678910function Gf()&#123; Gf.prototype.name = "vivian"; Gf.prototype.bar = "c++"; Gf.prototype.sayWhat = function()&#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf();gf1.sayWhat();var gf2 = new Gf(); 和构造函数不同的是这里新对象的属性和方法是所有实例都可以共享的，换句话说gf1和gf2访问的是同一份属性和方法。原型对象中除了我们赋予的属性外，还有一些内置的属性，所有原型对象都具备一个constructor属性，这个属性是一个指向包含prototype属性函数的一个指针（敢不敢再绕点！）。通过一幅图我们来清楚的理一下这个绕口的流程： 所有的对象都有一个原型对象（prototype），原型对象中有一个constructor属性指向包含prototype属性的函数，Gf的实例gf1和gf2都包含一个内部属性指向原型对象（在firefox浏览器中表现为私有属性proto），当我们访问一个对象中的属性时，首先会询问实例对象中有没有该属性，如果没有则继续查找原型对象。 使用原型对象 在前面的示例中，我们注意到在为原型对象添加属性时，需要每个都增加Gf.prototype，这个工作很重复，在上面对象的创建模式中，我们知道可以通过字面量的形式创建一个对象，这里我们也可以改进一下： 12345678function Gf()&#123;&#125;Gf.prototype = &#123; name : "vivian", bar : "c++", sayWhat : function()&#123; alert(this.name + "said:love you forever"); &#125;&#125; 这里有一个地方需要特别注意下，constructor属性不再指向对象Gf，因为每定义一个函数，就会同时为其创建一个prototype对象，这个对象也会自动获取一个新的constructor属性，这个地方我们使用Gf.prototype本质上覆写了原有的prototype对象，因此constructor也变成了新对象的constructor属性，不再指向Gf，而是Object:123var gf1 = new Gf();console.log(gf1.constructor == Gf);//falseconsole.log(gf1.constructor == Object)//true 一般情况下，这个微妙的改变是不会对我们造成影响的，但如果你对constructor有特殊的需求，我们也可以显式的指定下Gf.prototype的constructor属性：12345678910Gf.prototype = &#123; constructor : Gf, name : "vivian", bar : "c++", sayWhat : function() &#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf();console.log(gf1.constructor == Gf);//true 通过对原型对象模式的初步了解，我们发现所有的实例对象都共享相同的属性，这是原型模式的基本特点，但往往对于开发者来说这是把“双刃剑”，在实际开发中，我们希望的实例应该是具备自己的属性，这也是在实际开发中很少有人单独使用原型模式的主要原因。 构造函数和原型组合模式 在实际开发中，我们可以使用构造函数来定义对象的属性，使用原型来定义共享的属性和方法，这样我们就可以传递不同的参数来创建出不同的对象，同时又拥有了共享的方法和属性。 123456789101112function Gf(name,bar)&#123; this.name = name; this.bar = bar;&#125;Gf.prototype = &#123; constructor : Gf, sayWhat : function() &#123; alert(this.name + "said:love you forever"); &#125;&#125;var gf1 = new Gf("vivian", "f");var gf2 = new Gf("vivian1", "c"); 在这个例子中，我们再构造函数中定义了对象各自的属性值，在原型对象中定义了constructor属性和sayWhat函数，这样gf1和gf2属性之 间就不会产生影响了。这种模式也是实际开发中最常用的对象定义方式，包括很多js库（bootstrap等）默认的采用的模式。 *文章来自网络，如有侵权请联系进行删除，谢谢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[周末随拍（2016.11.13）]]></title>
      <url>2016%2F11%2F16%2Fthe-Accompanying-photograph%2F</url>
      <content type="text"><![CDATA[兴庆公园 兴庆公园 兴庆公园 兴庆公园 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔北广场音乐喷泉 大雁塔 小寨 #拍摄来自魅蓝E#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3导航动画切换]]></title>
      <url>2016%2F11%2F09%2FRotate-the-navigation%2F</url>
      <content type="text"><![CDATA[我们浏览有些手机网站时，有时会发现页面的导航打开动画很有意思，类似下图这种： 现在我们用html input表单以及css3实现这个功能，原理如下： html为用input 与label表单，label下边三个div表示导航的三条横线； 当点击label时，input会选中,与之对应的label下边三个div执行动画,其中第二个div让宽度为0，位置发生变化，第一个与第三个div执行旋转动画，形成×； 再次点击取消选中时，利用input的属性，恢复到选中之前的状态。 html代码如下： 12345678&lt;div class="nav_bar"&gt; &lt;input type="checkbox" id="nemu_button"&gt; &lt;label for="nemu_button"&gt; &lt;div class="line_top transition"&gt;&lt;/div&gt; &lt;div class="line_meddle transition"&gt;&lt;/div&gt; &lt;div class="line_bottom transition"&gt;&lt;/div&gt; &lt;/label&gt;&lt;/div&gt; css代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/*过渡动画transition*/.transition &#123; -webkit-transition: all .25s ease-in-out; -moz-transition: all .25s ease-in-out; -ms-transition: all .25s ease-in-out; -o-transition: all .25s ease-in-out; transition: all .25s ease-in-out;&#125;#nemu_button &#123; position: absolute; left: 9999px;&#125;label &#123; position: absolute; right:50px; cursor:pointer;&#125;label&gt;div &#123; width: 30px; height: 2px; margin-bottom: 8px; background: #fff;&#125;/*input选中是 label下边的三条横线的过渡动画*/input:checked + label .line_top &#123; margin-top: 15px; -webkit-transform: rotate(-45deg); -moz-transform: rotate(-45deg); -ms-transform: rotate(-45deg); -o-transform: rotate(-45deg); transform: rotate(-45deg);&#125;input:checked + label .line_meddle &#123; width: 0; margin-top: -15px; margin-left: 15px;&#125;input:checked + label .line_bottom &#123; margin-top: -5px; -webkit-transform: rotate(45deg); -moz-transform: rotate(45deg); -ms-transform: rotate(45deg); -o-transform: rotate(45deg); transform: rotate(45deg);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[数字化Loading]]></title>
      <url>2016%2F11%2F07%2FLoading-Page%2F</url>
      <content type="text"><![CDATA[js页面从0~100%的loading； javascript代码： 12345678910111213141516171819function setSB(v, el) &#123; //判断页面是否加载完成 if (document.readyState == "complete") &#123; valueEl = el.children[0]; valueEl.innerText = v + "%";//显示百分比 &#125; &#125; function fakeProgress(v, el) &#123; if (v &gt; 100)&#123;//加载完成 document.querySelector('#text').innerHTML="加载完成"; setTimeout(function()&#123; document.querySelector('#sb').style.display="none"; &#125;,200); &#125; else &#123; setSB(v, el); window.setTimeout("fakeProgress(" + (++v) + ", document.all['" + el.id + "'])", 20); &#125; &#125; html代码： 123456789&lt;body onload="fakeProgress(0, sb)"&gt; &lt;center&gt; &lt;p id="text"&gt;正在载入中，请稍侯……&lt;/p&gt; &lt;span id='sb' style="width: 302px"&gt; &lt;div&gt;&lt;/div&gt; &lt;div style="font-size: 9pt; width: 100%; text-align: center"&gt;&lt;/div&gt; &lt;/span&gt; &lt;/center&gt;&lt;/body&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js轮播图(适用于PC)]]></title>
      <url>2016%2F11%2F03%2F20161103js-Slider%2F</url>
      <content type="text"><![CDATA[实现自动左右轮播 鼠标移入停止轮播，鼠标移开继续轮播 prev next点击左右切换 点击下边导航可以跳转到相应的页 首先引入自己封装的简单的js运动库 move.js1&lt;script src="move.js"&gt;&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132function getStyle(obj, name) &#123; if (obj.currentStyle) &#123; return obj.currentStyle[name]; &#125; else &#123; return getComputedStyle(obj, false)[name]; &#125; &#125; function startMove(obj, attr, iTarget) &#123; clearInterval(obj.timer); obj.timer = setInterval(function() &#123; var cur = 0; if (attr == 'opacity') &#123; cur = parseFloat(getStyle(obj, attr)) * 100; &#125; else &#123; cur = parseInt(getStyle(obj, attr)); &#125; var speed = parseInt(iTarget - cur) / 6; speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (cur == iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if (attr == 'opacity') &#123; obj.style.filter = 'alpha(opacity:' + (cur + speed) + ')'; obj.style.opacity = (cur + speed) / 100; &#125; else &#123; obj.style[attr] = cur + speed + 'px'; &#125; &#125; &#125;, 30); &#125; javascript代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596function getByClass(oParent, sClass) &#123; var aEle = oParent.getElementsByTagName('*'); var aResult = []; for (var i = 0; i &lt; aEle.length; i++) &#123; if (aEle[i].className = sClass) &#123; aResult.push(aEle[i]); &#125; return aResult; &#125;&#125;window.onload = function() &#123; var con = document.getElementById('container'); var bd = document.getElementById('bd'); var oUl = bd.querySelector('ul'); var oLi = bd.querySelectorAll('li'); var prev = document.getElementById('prev'); var next = document.getElementById('next'); var hd = document.getElementById('hd'); var piont = hd.getElementsByTagName('span'); var nowNav = document.querySelector('.nowNav'); var op = oLi[0].offsetWidth; var move = null; var speed = 0; var now = 0; var navi = 1; document.querySelector('.navig').innerHTML = oLi.length; oUl.style.width = op * oLi.length + 'px'; // 鼠标滑过时停止轮播；滑出式又开始轮播 con.onmouseover = function() &#123; clearInterval(move); &#125;; con.onmouseout = function() &#123; autoMove(); &#125;; // 点击上边的点，跳到相应的页面 for (var i = 0; i &lt; piont.length; i++) &#123; piont[i].index = i; piont[i].onmouseover = function() &#123; // console.log(oUl.offsetLeft); now = this.index; tab(); &#125; &#125; // 点击上边的点，跳到相应的页面函数 function tab() &#123; for (var i = 0; i &lt; piont.length; i++) &#123; piont[i].className = ''; &#125; piont[now].className = 'cur'; startMove(oUl, 'left', -1200 * now); &#125; // 点击向前一页 prev.onclick = function() &#123; speed -= op; if (oUl.offsetLeft &gt;= 0) &#123; speed = 3600; &#125; moving(); now--; if (now == -1) &#123; now = piont.length - 1; &#125; tab(); if (navi &lt; 2) &#123; navi = 5; &#125; nowNav.innerHTML = navi-1; navi--; &#125; // 点击向后一页 next.onclick = function() &#123; speed += op; if (oUl.offsetLeft &lt;= -3600) &#123; speed = 0; &#125; moving(); now++; if (now == piont.length) &#123; now = 0 &#125; tab(); navi++; if (navi &gt; 4) &#123; navi = 1; &#125; nowNav.innerHTML = navi; &#125; // 轮播的函数 function moving() &#123; startMove(oUl, 'left', -speed); &#125; // 自动轮播 轮播间隔时间3000 function autoMove() &#123; move = setInterval(next.onclick, 3000); &#125; autoMove(); html代码如下：123456789101112131415161718192021&lt;div class="container" id="container"&gt; &lt;div id="bd"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src="images/0.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/1.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/2.jpg" alt=""&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="images/3.jpg" alt=""&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="control" id="control"&gt; &lt;span class="prev" id="prev"&gt;&amp;lsaquo;&lt;/span&gt; &lt;span class="next" id="next"&gt;&amp;rsaquo;&lt;/span&gt; &lt;/div&gt; &lt;p class="navigtion"&gt;&lt;span class="nowNav"&gt;1&lt;/span&gt;/&lt;span class="navig"&gt;&lt;/span&gt;&lt;/p&gt; &lt;div id="hd"&gt; &lt;span class="cur"&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/div&gt; css代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293body &#123; margin: 0; padding: 0; &#125; ul, li &#123; margin: 0; padding: 0; list-style: none; &#125; .container &#123; position: relative; width: 1200px; height: 610px; margin: 150px auto; overflow: hidden; &#125; .container #bd ul, .container #bd li &#123; height: 100%; &#125; .container #bd ul &#123; position: absolute; top: 0; left: 0; &#125; .container #bd li &#123; float: left; width: 1200px; &#125; .container #bd li img &#123; height: 100%; width: 100%; &#125; .control span &#123; position: absolute; top: 0; bottom: 0; z-index: 19; width: 32px; height: 32px; margin: auto; background: #ff0; font-size: 32px; line-height: 30px; text-align: center; cursor: pointer; &#125; .control span.next &#123; right: 0; &#125; #hd &#123; position: absolute; z-index: 29; width: 20%; left: 0; right: 0; margin: auto; bottom: 2%; text-align: center; &#125; #hd span &#123; width: 10px; height: 10px; background: #f00; border-radius: 50%; display: inline-block; cursor: pointer; &#125; #hd .cur &#123; background: #ff0; &#125; .navigtion &#123; position: absolute; bottom: 3%; width: 10%; /* margin: 0 auto; */ display: block; text-align: center; left: 45%; &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js实现活动倒计时]]></title>
      <url>2016%2F11%2F02%2Fjavascript-add-Date%2F</url>
      <content type="text"><![CDATA[js倒计时 包括天数、时、分、秒 手动填写活动开始/结束时间 javascript 获取当前时间 然后在填写活动开始/结束时间 javascript 代码如下： 12345678910111213141516171819var now = new Date();//获取当前时间function GetServerTime() &#123; var urodz = new Date("11/7/2016 10:00:00"); //填写活动开始/结束时间 now.setTime(now.getTime() + 250); days = (urodz - now) / 1000 / 60 / 60 / 24; //获取天数 daysRound = Math.floor(days); hours = (urodz - now) / 1000 / 60 / 60 - (24 * daysRound); //获取小时 hoursRound = Math.floor(hours); minutes = (urodz - now) / 1000 / 60 - (24 * 60 * daysRound) - (60 * hoursRound); //获取分钟 minutesRound = Math.floor(minutes); seconds = (urodz - now) / 1000 - (24 * 60 * 60 * daysRound) - (60 * 60 * hoursRound) - (60 * minutesRound); //获取秒钟 secondsRound = Math.round(seconds); document.getElementById("date").innerHTML = daysRound; //把时分秒显示出来 document.getElementById("time").innerHTML = hoursRound + "Hours," + minutesRound + "Minutes," + secondsRound + "Seconds";&#125;//保持页面1/4秒重新获取一次 setInterval("GetServerTime()", 250); html代码：123&lt;p class="time"&gt; &lt;span id="date"&gt;&lt;/span&gt;&lt;span class="white14b"&gt;Days,&lt;br/&gt;&lt;/span&gt;&lt;span id="time"&gt;&lt;/span&gt;&lt;/p&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript基本运动框架]]></title>
      <url>2016%2F11%2F01%2Fmy-blog%2F</url>
      <content type="text"><![CDATA[基础的形变 长度、宽度 字体大小 边框宽度 透明度 123456789101112131415161718192021222324252627282930313233//基本的运动动画function getStyle(obj, name) &#123;//获取行内的样式 name表示获取的样式 if (obj.currentStyle) &#123; return obj.currentStyle[name]; &#125; else &#123; return getComputedStyle(obj, false)[name]; &#125; &#125; //运动框架主体function startMove(obj, attr, iTarget) &#123;//attr 变化的样式；iTarget 最后变化目标 clearInterval(obj.timer);//初始化 清除所有的计时器 obj.timer = setInterval(function() &#123; var cur = 0; if (attr == 'opacity') &#123;//如果变化的是透明度 执行下边 cur = parseFloat(getStyle(obj, attr)) * 100; &#125; else &#123; cur = parseInt(getStyle(obj, attr)); &#125; var speed = parseInt(iTarget - cur) / 6;// 动画进行的事件 6可以修改 speed = speed &gt; 0 ? Math.ceil(speed) : Math.floor(speed); if (cur == iTarget) &#123; clearInterval(obj.timer); &#125; else &#123; if (attr == 'opacity') &#123;//如果变化的是透明度 执行下边 obj.style.filter = 'alpha(opacity:' + (cur + speed) + ')'; obj.style.opacity = (cur + speed) / 100; &#125; else &#123; obj.style[attr] = cur + speed + 'px'; &#125; &#125; &#125;, 30);&#125; 调用： 123456789//改变宽度oDiv.onmouseover = function () &#123; startMove(this, 'width', 200);&#125;//透明度oDiv.onmouseout = function () &#123; startMove(this, 'opacity', 30);&#125; 颜色的渐变 通过修改元素的rgb值 来实现渐变 1234567891011121314151617181920212223242526272829303132//颜色的渐变动画 改变的是 rgb值//所有代码的执行时间只有24毫秒左右。 function fadeColor(from, to, callback, duration, totalFrames) &#123;//form 初始颜色 to最终颜色 callback完后的回调函数 duration 动画执行时间 totalFrames总帧数，默认为持续秒数*15帧，也即每秒15帧 //用一个函数来包裹setTimeout，根据帧数来确定延时 function doTimeout(color, frame) &#123; setTimeout(function() &#123; try &#123; callback(color); &#125; catch (e) &#123; JSLog.write(e); &#125; &#125;, (duration * 1000 / totalFrames) * frame); //总持续秒数/每秒帧数*当前帧数=延时(秒)，再乘以1000作为延时(毫秒) &#125; // 整个渐变过程的持续时间，默认为1秒 var duration = duration || 1; // 总帧数，默认为持续秒数*15帧，也即每秒15帧 var totalFrames = totalFrames || duration * 15; var r, g, b; var frame = 1; //在第0帧设置起始颜色 doTimeout('rgb(' + from.r + ',' + from.g + ',' + from.b + ')', 0); //计算每次变化所需要改变的rgb值 while (frame &lt; totalFrames + 1) &#123; r = Math.ceil(from.r * ((totalFrames - frame) / totalFrames) + to.r * (frame / totalFrames)); g = Math.ceil(from.g * ((totalFrames - frame) / totalFrames) + to.g * (frame / totalFrames)); b = Math.ceil(from.b * ((totalFrames - frame) / totalFrames) + to.b * (frame / totalFrames)); // 调用本frame的doTimeout doTimeout('rgb(' + r + ',' + g + ',' + b + ')', frame); frame++; &#125;&#125; 调用:123456789101112131415oDiv.onmouseover = function () &#123; fadeColor(&#123; r: 0, g: 0, b: 0 &#125;, //star color &#123; r: 18, g: 162, b: 143 &#125;, //end color function (color) &#123; oDiv6.style.borderColor = color; &#125;, 0.25, 10);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 在github上部署成功]]></title>
      <url>2016%2F10%2F31%2Fmy-new-post-0%2F</url>
      <content type="text"><![CDATA[终于把本地Hexo部署到github上了，之前不知为什么 就是不成功，今天重新试了一下命令 就成功了 命令为： 发布新文章 首先打开文件夹 hexo，再右键打开Git Bash， 在Git Bash 上执行下列命令： 1hexo new "my new post" //"my new post"为文件名 在hexo文件夹下 source_post 中打开my-new-post.md进行编辑 或者在存放博客的目录下 1hexo n "新建博客的名字" Front-matterFront-matter 是文件最上方以 — 分隔的区域，用于指定个别文件的变量，举例来说：123title: Hello Worlddate: 2013/7/13 20:46:25--- 以下是预先定义的参数，您可在模板中使用这些参数值并加以利用。 参数 描述 默认值 123456789101112131415layout: 布局 title: 标题 date: 建立日期 文件建立日期updated : 更新日期 文件更新日期comments: 开启文章的评论功能 truetags: 标签（不适用于分页） categories: 分类（不适用于分页） permalink: 覆盖文章网址 举例： 123456title: 标题date: 2016-11-01 11:42:21categories: webtags: [javascript,css] //多个标签用[,]标记description: 这是说明，在首页显示的文字--- 本地预览hexo 本地环境查看时首先打开文件夹 hexo， 在内执行以下命令 1hexo s -p 5000 //后边的-p 5000是修改端口 然后打开浏览器 输如http://localhost:5000/即可查看 部署到GitHub123hexo g //生成静态文件hexo s //在本地预览效果hexo d //同步到github 上 -&gt; 参考&lt;:]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[这是我的第一篇Hexo博客]]></title>
      <url>2016%2F10%2F21%2FMy-New-Post%2F</url>
      <content type="text"><![CDATA[一天不独处，我就会变得虚弱。我不以孤独为荣，但我以此为生。 ————布考斯基 这是我的第一篇博客，我现在正在熟悉Hexo,所使用的主题是NexT,我觉得这个主题简洁大方，而且里边的缓动效果特别舒服。 我以后会不定时的在这上边更新一些博客，什么类型的都有，写给自己看，写给多年后的自己看。 加油， 每天进步一点，不断努力，终会取得不错的成绩！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>2016%2F10%2F21%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
